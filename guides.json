{
    "documentation": [
        {
            "id": "Documentation-index",
            "name": "欢迎来到 NipaPlay 文档",
            "content": "# 欢迎来到 NipaPlay 文档\n\n![GitHub release](https://img.shields.io/github/v/release/mcdfsteve/nipaplay-reload?style=flat-square&color=blue) ![GitHub downloads](https://img.shields.io/github/downloads/mcdfsteve/nipaplay-reload/total?style=flat-square&color=green) ![Platform support](https://img.shields.io/badge/platform-Windows%20%7C%20macOS%20%7C%20Linux%20%7C%20Android%20%7C%20iOS-lightgrey?style=flat-square) ![License](https://img.shields.io/github/license/mcdfsteve/nipaplay-reload?style=flat-square)\n\nNipaPlay-Reload 是一个现代化的跨平台视频播放器，致力于为用户提供流畅、美观且功能丰富的观影体验。它支持本地视频播放、弹幕显示、多格式字幕、多轨道音视频，并可无缝整合 Emby 和 Jellyfin 媒体服务器。\n\n我们的目标是打造一个开源、社区驱动的播放器，让每个人都能享受到最好的观影乐趣。无论你是想要播放本地收藏，还是连接家庭媒体中心，NipaPlay 都能满足你的需求。\n\n## 文档导航\n\n本文档将引导你从安装到熟练使用 NipaPlay 的完整过程：\n\n### 入门篇\n\n- [快速开始](#Documentation-quick-start) - 几分钟完成安装和首次播放\n- [安装指南](#Documentation-installation) - 详细的平台安装步骤  \n- [安装后设置](#Documentation-post-install) - 连接媒体服务器和基本配置\n\n### 使用篇\n\n- [使用指南](#Documentation-user-guide) - 界面操作和功能介绍\n- [媒体服务器整合](#Documentation-server-integration) - Emby/Jellyfin 连接指南\n\n### 进阶篇\n\n- [高级设置](#Documentation-settings) - 播放器内核和性能优化\n- [常见问题](#Documentation-faq) - 问题解答和解决方案\n- [故障排查](#Documentation-troubleshooting) - 问题诊断和日志获取\n\n### 其他\n\n- [隐私与数据](#Documentation-privacy) - 数据处理说明\n- [更新与发布](#Documentation-release-channels) - 获取更新的方式\n\n## 💬 需要帮助？\n\n- 查看我们的 [常见问题](#Documentation-faq) 和 [故障排查](#Documentation-troubleshooting) 页面\n- 在 [GitHub Issues](https://github.com/mcdfsteve/nipaplay-reload/issues) 报告问题\n- 想要贡献代码？请查看我们的贡献指南\n\n---\n\n**注意**：NipaPlay 是一个快速发展的项目，功能和界面可能会频繁更新。请定期检查更新并关注我们的发布说明！\n\n---\n\n**➡️ 下一篇: [快速开始](#Documentation-quick-start)**\n"
        },
        {
            "id": "Documentation-quick-start",
            "name": "快速开始",
            "content": "# 快速开始\n\n用最少步骤完成首次播放，详情与各平台命令请参考安装指南。\n\n## 1. 安装\n\n- 按你的平台前往[安装指南](#Documentation-installation)完成安装。\n\n## 2. 首次启动与基础设置\n\n1. 启动 NipaPlay。\n2. 可以直接在视频播放页面选择视频进行播放，或拖拽视频到页面也可以直接开始播放。\n2. 在“媒体库”中：\n\t- 添加本地媒体目录，或\n\t- 连接 Emby/Jellyfin 服务器（可稍后在设置中完成）。\n\n## 3. 播放\n\n- 返回媒体库，选择任意视频开始播放；播放中可在控制栏切换字幕、弹幕与倍速。\n\n## 可选：安装后优化\n\n- 需要远程媒体或高级功能？继续阅读[安装后设置](#Documentation-post-install)。\n\n---\n\n**⬅️ 上一篇: [欢迎来到 NipaPlay 文档](#Documentation-index)** | **➡️ 下一篇: [安装指南](#Documentation-installation)**\n"
        },
        {
            "id": "Documentation-installation",
            "name": "安装",
            "content": "# 安装\n\n选择你的平台并按照步骤完成安装。\n\n## Windows\n\n- 前往 [GitHub Release 页面](https://github.com/Shinokawa/NipaPlay-Reload/releases) 下载安装包（或压缩包）；执行安装或解压后运行。\n- 首次启动被 Defender 拦截时，点击\"更多信息→仍要运行\"。\n\n## macOS\n\n- 推荐 Homebrew：\n\n    ```bash\n    brew tap Shinokawa/nipaplay-reload\n    brew install --cask nipaplay-reload\n    ```\n\n- 或从 [Release 页面](https://github.com/Shinokawa/NipaPlay-Reload/releases) 下载 dmg，将应用拖至\"应用程序\"；未签名提示：在设置-隐私与安全性中选择仍要打开。\n\n## Linux\n\n- Arch Linux（x86_64）：\n\n    ```bash\n    paru -S nipaplay-reload-bin\n    # 或\n    yay -S nipaplay-reload-bin\n    ```\n\n- 其他发行版：从 [Release 页面](https://github.com/Shinokawa/NipaPlay-Reload/releases) 下载对应构建包并按常规方式安装/运行。\n\n## Android\n\n- 从 [Release 页面](https://github.com/Shinokawa/NipaPlay-Reload/releases) 下载匹配架构的 APK（常见 arm64），启用\"未知来源\"后安装。\n\n## iOS\n\niOS 用户可以选择以下几种安装方式：\n\n### 方式一：侧载工具安装（推荐）\n\n**使用爱思助手**：\n\n1. 在电脑上下载并安装 [爱思助手](https://www.i4.cn/)\n2. 从 [Release 页面](https://github.com/Shinokawa/NipaPlay-Reload/releases) 下载 `.ipa` 文件\n3. 连接 iOS 设备到电脑\n4. 打开爱思助手「工具箱」→ 选择「IPA签名」→ 导入IPA文件\n5. 点击「使用Apple ID签名」→ 登录Apple ID → 勾选设备标识\n6. 在设备上：设置 → 通用 → VPN与设备管理 → 信任企业级应用\n\n**使用 AltStore**：\n\n1. 在电脑上安装 [AltStore](https://altstore.io/) 和 iTunes/Apple Music\n2. 通过 AltStore 在设备上安装 AltStore 应用\n3. 使用 AltStore 侧载 `.ipa` 文件\n4. 定期刷新签名（免费账号 7 天刷新一次）\n\n### 方式二：Xcode 自签名（技术用户）\n\n如果您有 macOS 设备并熟悉 Xcode 开发：\n\n1. **准备环境**：\n   - 一台 macOS 设备\n   - Xcode（从 App Store 免费下载）\n   - iOS 设备和数据线\n\n2. **获取源码**：\n   - 从 [Release 页面](https://github.com/Shinokawa/NipaPlay-Reload/releases) 下载源码包\n\n3. **配置和构建**：\n   - 解压源码并用 Xcode 打开 `ios/Runner.xcworkspace`\n   - 配置 Bundle Identifier 和开发者签名\n   - 连接设备并构建安装\n\n\n### 签名说明\n\n- **免费 Apple ID**：签名有效期 7 天，需定期刷新\n\n---\n\n**⬅️ 上一篇: [快速开始](#Documentation-quick-start)** | **➡️ 下一篇: [安装后设置](#Documentation-post-install)**\n"
        },
        {
            "id": "Documentation-post-install",
            "name": "安装后设置",
            "content": "# 安装后设置\n\n## 基本设置\n\n- 主题与外观：自定义背景/壁纸模糊。\n- 媒体库：添加本地目录或网络挂载目录。\n\n## 连接媒体服务器\n\n- Emby/Jellyfin：\n  - 在“设置→远程媒体库/远程访问”填写服务器地址、用户名与密码。\n  - 在媒体库-本地媒体库中添加媒体服务器\n- 首次连接后可在网络媒体库页面中选择要显示的媒体库，查看媒体库内容。\n\n## 字幕与弹幕\n\n- 支持外挂字幕（ASS/SRT）与内嵌字幕；可选择默认字幕轨。\n- 弹幕：支持滚动/顶部/底部、轨道管理、位置记忆；可挂载本地弹幕（json/xml）。\n\n## 播放器内核\n\n- 可在设置中切换不同播放器内核（如 FVP（MDK）、Media Kit（Libmpv）、Video Player），以获得更佳兼容性或性能。\n\n---\n\n**⬅️ 上一篇: [安装指南](#Documentation-installation)** | **➡️ 下一篇: [使用指南](#Documentation-user-guide)**\n"
        },
        {
            "id": "Documentation-user-guide",
            "name": "使用指南",
            "content": "# 使用指南\n\n## 界面概览\n\n- **顶部导航**：进入主页、视频播放、媒体库、设置、新番更新等功能区域\n- **主页**：展示新番推荐、最近观看记录和个性化推荐内容\n- **媒体库**：管理本地媒体文件和远程媒体服务器连接\n\n## 播放功能\n\n### 播放控制\n\n- **基础控制**：播放/暂停、进度条拖拽、音量调节\n- **播放速度**：支持多档倍速播放（0.5x - 2.0x）\n- **全屏模式**：支持全屏播放和窗口化切换\n\n### 弹幕与字幕\n\n- **弹幕显示**：支持开启/关闭弹幕显示\n- **字幕管理**：多字幕轨道选择和样式自定义\n- **显示设置**：弹幕透明度、字体大小、显示区域等个性化调节\n\n### 播放历史\n\n- **观看记录**：自动记录观看进度和历史\n- **续播功能**：支持一键续播上次观看位置\n- **历史管理**：查看和管理完整的观看历史记录\n\n## 媒体库管理\n\n### 本地媒体\n\n- **文件扫描**：自动扫描指定目录下的视频文件\n- **媒体信息**：显示文件详细信息和元数据\n- **分类浏览**：按类型、日期等维度组织媒体内容\n\n### 远程服务器\n\n详细的服务器连接和使用方法请参考 [媒体服务器整合](#Documentation-server-integration)。\n\n## 应用内导航\n\n应用内已包含完整的快捷键说明，可在相应界面查看所有可用的键盘快捷方式。\n\n---\n\n**⬅️ 上一篇: [安装后设置](#Documentation-post-install)** | **➡️ 下一篇: [媒体服务器整合](#Documentation-server-integration)**\n"
        },
        {
            "id": "Documentation-server-integration",
            "name": "媒体服务器整合（Emby/Jellyfin）",
            "content": "# 媒体服务器整合（Emby/Jellyfin）\n\n## 连接前准备\n\n### 媒体库要求\n\nNipaPlay 对媒体库类型有特定要求：\n\n**✅ 支持的媒体库类型**：\n\n- 电影媒体库（Movies）\n- 剧集媒体库（TV Shows）\n\n**❌ 不支持的媒体库类型**：\n\n- 混合媒体库（Mixed Content）\n- 文件夹类型的媒体库\n- 其他自定义类型\n\n**建议配置**：\n\n- 在服务器端创建独立的电影和剧集媒体库\n- 确保媒体文件有良好的刮削信息（海报、元数据、演员信息等）\n- 避免将不同类型的媒体混合在同一个库中\n\n### 性能考虑\n\n**大型媒体库注意事项**：\n\n- 媒体数量过于庞大（如上万个媒体）时，初次连接选择媒体库可能会出现加载缓慢\n- 这是正常现象，耐心等待初次加载完成\n- 后续访问会使用本地缓存，速度会明显提升\n\n## 连接步骤\n\n1. **打开设置**：设置 → 远程媒体库\n2. **输入服务器信息**：\n   - 服务器地址（IP:端口 或 域名）\n   - 用户名和密码\n   - 如使用 HTTPS，确保地址以 https:// 开头\n3. **保存配置**：点击保存并等待连接验证\n4. **选择媒体库**：连接成功后选择要同步的媒体库\n5. **开始使用**：返回媒体库界面查看服务器内容\n\n## 常见连接问题\n\n### 连接失败\n\n**检查项目**：\n\n- 服务器地址和端口是否正确\n- 网络连通性（同一局域网/公网访问）\n- 用户名和密码是否准确\n- 服务器是否正常运行\n\n### 403 Forbidden 错误\n\n**原因**：服务器管理员配置了客户端访问限制\n\n**解决方案**：\n\n- 联系服务器管理员\n- 请求将 NipaPlay 加入客户端白名单\n- 确认是否有特定的客户端标识要求\n\n**注意**：此问题无法通过客户端设置解决，需要服务器端配合。\n\n### 认证问题\n\n**症状**：提示用户名或密码错误\n\n**解决方案**：\n\n- 确认服务器端账户信息\n- 检查账户是否有媒体库访问权限\n- 尝试在服务器端重置密码\n\n### 播放异常\n\n**问题**：能连接但无法播放内容\n\n**解决方案**：\n\n- 尝试切换播放器内核（Libmpv/MDK/Video Player）\n- 检查服务器转码设置\n- 确认网络带宽是否足够\n\n---\n\n**⬅️ 上一篇: [使用指南](#Documentation-user-guide)** | **➡️ 下一篇: [高级设置](#Documentation-settings)**\n"
        },
        {
            "id": "Documentation-settings",
            "name": "高级设置",
            "content": "# 高级设置\n\n## 播放器内核选择\n\nNipaPlay 提供多种播放器内核，各有特点：\n\n### 内核对比\n\n- **Libmpv（推荐）**：\n  - ✅ 支持硬件解码，性能优异\n  - ✅ 兼容性强，支持各种视频格式和字幕\n  - ✅ 解码能力完整（需 Windows 用户手动优化，见下文）\n  - 🎯 **最推荐使用**，特别是性能受限的设备\n\n- **MDK**：\n  - ✅ 跨平台支持良好\n  - ❌ 暂时不支持硬件解码\n  - ⚠️ 性能受限设备不推荐使用\n\n- **Video Player**：\n  - ✅ Flutter 官方播放器，稳定性好\n  - ⚠️ 功能相对基础，兼容性一般\n  - 🔧 作为备选方案使用\n\n### 切换建议\n\n- **首选**：Libmpv（性能和兼容性最佳）\n- **问题排查**：如遇播放问题，可尝试切换到其他内核进行对比\n- **性能考虑**：低配置设备务必使用 Libmpv 以获得硬件解码支持\n\n## Windows 平台解码器优化\n\n> **重要**：Windows 版本由于上游 media-kit 的限制，默认的 libmpv 库解码器不够完整，可能无法播放某些格式或字幕（如 HDR、10bit、PGS字幕等）。\n\n### 解决方案：手动替换 libmpv 库\n\n社区提供了完整版本的 libmpv 库来解决解码器缺失问题：\n\n#### 📋 兼容性要求\n\n- **V3 版本**：需要 CPU 支持 AVX2 指令集（Intel 4代酷睿及以上，约2013年后）\n- **普通版本**：需要 CPU 支持 AVX 指令集（Intel 2代酷睿及以上，约2011年后）\n- **不支持 AVX**：无法使用此优化方案\n\n#### 🔧 替换步骤\n\n1. **检查 CPU 兼容性**：\n   - 使用 CPU-Z 等工具确认 CPU 指令集支持\n   - Intel 4代（Haswell）及以上推荐使用 V3 版本\n   - Intel 2-3代可尝试普通版本\n\n2. **下载完整版 libmpv**：\n   - 访问 [MPV Windows 构建页面](https://sourceforge.net/projects/mpv-player-windows/files/libmpv/)\n   - 下载适合的版本（推荐 V3 版本获得最佳兼容性）\n\n3. **替换库文件**：\n   - 关闭 NipaPlay\n   - 找到安装目录（通常在 `Program Files` 或 `AppData` 下）\n   - 备份原始的 `libmpv-2.dll` 文件\n   - 将下载的 `libmpv-2.dll` 替换到安装目录\n   - 重新启动 NipaPlay\n\n#### ⚠️ 注意事项\n\n- **CPU 不兼容**：使用不匹配的版本可能导致程序崩溃或无法启动\n- **备份原文件**：替换前务必备份原始库文件，以便回滚\n- **自承风险**：此为社区解决方案\n\n#### 🎯 预期改善\n\n替换后可解决以下问题：\n\n- H.264/H.265 高级格式播放失败\n- HDR10、10bit 视频黑屏\n- 部分 AVC 编码无法解码\n- 杜比视界等高级格式不支持\n\n## 弹幕引擎配置\n\nNipaPlay 支持GPU与CPU渲染的弹幕引擎：\n- GPU渲染更高效，不过现阶段还有部分不完善的地方\n- CPU渲染更稳定，性能开销较大\n\n## 其他设置选项\n\n### 日志与调试\n\n**开发者选项** 中的日志功能对问题反馈非常重要：\n\n**日志查看方式**：\n\n1. 进入 设置 → 开发者选项 → 终端输出\n2. 查看实时日志信息\n3. 支持复制日志内容用于问题反馈\n\n**移动端特色功能**：\n\n- **Android/平板**：支持将日志导出为二维码，便于快速分享\n- **跨设备传输**：通过二维码可快速将日志信息传输到其他设备\n\n**问题反馈建议**：\n\n- 在 GitHub Issues 中提交问题时\n- 附带相关的日志信息\n- 包含平台信息和详细的重现步骤\n- 有助于开发者快速定位和解决问题\n\n详细的日志获取步骤可参考 [故障排查](#Documentation-troubleshooting) 部分。\n\n### 解码与性能优化\n\n- **硬件/软件解码**：根据设备性能选择合适的解码方式\n- **缓冲策略**：调整视频缓冲参数以适应网络环境\n- **性能模式**：在性能和画质间找到平衡点\n\n### 外观个性化\n\n- **主题选择**：nipaplay/fluentui主题切换\n- **壁纸设置**：自定义应用背景\n- **透明度调整**：界面透明效果控制\n- **毛玻璃效果**：现代化界面视觉效果强度调节\n\n---\n\n**⬅️ 上一篇: [媒体服务器整合](#Documentation-server-integration)** | **➡️ 下一篇: [常见问题](#Documentation-faq)**\n"
        },
        {
            "id": "Documentation-faq",
            "name": "常见问题（FAQ）",
            "content": "# 常见问题（FAQ）\n\n以最短答案直达问题核心，详细步骤请跳转到对应章节。\n\n## 安装与启动\n\n- macOS 无法打开（未验证开发者）\n\t- 系统设置 → 隐私与安全性 → 仍要打开。\n- Windows 被 Defender 拦截\n\t- 点击“更多信息 → 仍要运行”。\n- iOS 侧载/签名问题（安装失败、签名过期、无法打开）\n\t- 请参考[安装指南 - iOS](#Documentation-installation#ios)；按所用工具（爱思助手/AltStore/Xcode）执行即可。\n\n## 播放与性能\n\n- 启动后黑屏/无声/卡顿\n\t- 见[故障排查](#Documentation-troubleshooting)；可先尝试切换内核、更新驱动、启用硬解。\n- 用哪个播放器内核最好？\n\t- 推荐使用 Libmpv；差异与取舍见[高级设置 - 播放器内核选择](#Documentation-settings#播放器内核选择)。\n\n## 服务器整合（Emby/Jellyfin）\n\n- 无法连接、403 Forbidden、或认证失败\n\t- 连接步骤与常见错误见[媒体服务器整合](#Documentation-server-integration)。403 多由服务器端限制导致，需联系管理员放行客户端。\n- 媒体库类型支持吗？\n\t- 仅支持“电影/剧集”库类型；详情见[媒体服务器整合 - 媒体库要求](#Documentation-server-integration#媒体库要求)。\n- 初次选择媒体库很慢\n\t- 大库初次加载耗时较长，完成后会缓存；说明见[媒体服务器整合](#Documentation-server-integration#性能考虑)。\n\n## 弹幕与字幕\n\n- 弹幕显示异常/需要调整效果\n\t- 请查看[高级设置 - 弹幕引擎配置](#Documentation-settings#弹幕引擎配置)。\n\n## 故障与恢复\n\n- Windows：有进程但不出界面（断电后）\n\t- 原因与一键修复见[故障排查 - 意外断电后无法启动](#Documentation-troubleshooting#意外断电后无法启动-nipaplay（windows）)。\n- 如何导出日志反馈问题？\n\t- 步骤与注意事项见[故障排查 - 获取日志](#Documentation-troubleshooting#获取日志)。\n\n---\n\n**⬅️ 上一篇: [高级设置](#Documentation-settings)** | **➡️ 下一篇: [故障排查](#Documentation-troubleshooting)**\n"
        },
        {
            "id": "Documentation-troubleshooting",
            "name": "故障排查",
            "content": "# 故障排查\n\n## 常见症状与处理\n\n- 启动崩溃/无法启动：删除配置（备份后）、重装、查看日志。\n- 无法播放：尝试更换播放器内核、检查解码与硬件加速。\n- 无法扫描媒体：检查目录权限（桌面系统）、存储权限（Android）。\n- 界面卡顿：关闭高占用程序，检查 GPU 驱动与系统更新。\n\n## 应用启动问题\n\n### 意外断电后无法启动 NipaPlay（Windows）\n\n**症状**：电脑在运行中意外死机、断电或蓝屏重启后，NipaPlay 无法正常启动\n\n**具体表现**：\n\n- 启动 NipaPlay 后有进程在运行（可在任务管理器中看到）\n- 但是不会显示用户界面（UI 界面不出现）\n- 卸载重装应用也无法解决问题\n\n**原因**：意外断电导致配置文件 `shared_preferences.json` 损坏\n\n**解决方案**：\n\n1. **完全关闭 NipaPlay**：\n   - 在任务管理器中结束所有 NipaPlay 相关进程\n\n2. **找到配置文件**：\n   - 按 `Win + R` 打开运行对话框\n   - 输入 `%APPDATA%` 并回车，或者直接输入：\n\n     ```text\n     %APPDATA%\\Roaming\\com.aimessoft\\nipaplay\n     ```\n\n   - 找到 `shared_preferences.json` 文件\n\n3. **删除损坏的配置文件**：\n   - 删除 `shared_preferences.json` 文件\n   - （可选）备份该文件以便后续分析问题\n\n4. **重新启动应用**：\n   - 启动 NipaPlay，应用将自动创建新的配置文件\n   - 应用会以默认设置启动\n\n\n## Windows 特定问题\n\n### 播放 3 秒后崩溃/黑屏\n\n**症状**：视频播放几秒钟后程序崩溃或显示黑屏\n\n**可能原因**：\n\n- libmpv 解码器不完整，无法处理特定视频格式\n- CPU 指令集不支持当前使用的 libmpv 版本\n\n**解决方案**：\n\n1. 切换到其他播放器内核（MDK 或 Video Player）\n2. 如使用 Libmpv 内核，参考 [高级设置 - Windows 平台解码器优化](#Documentation-settings#windows-平台解码器优化) 替换完整版 libmpv\n3. 确认 CPU 支持相应指令集（AVX/AVX2）\n\n### 高清/HDR 视频无法播放\n\n**症状**：H.265、10bit、HDR、杜比视界以及PGS字幕等无法播放\n\n**解决方案**：\n\n1. 参考 [高级设置](#Documentation-settings) 中的 Windows 解码器优化方案\n2. 确保显卡驱动为最新版本\n3. 尝试启用硬件解码（如支持）\n\n### 替换 libmpv 后程序无法启动\n\n**症状**：替换 libmpv-2.dll 后程序直接报错或崩溃\n\n**可能原因**：\n\n- CPU 不支持所选 libmpv 版本的指令集要求\n- 下载的库文件损坏或版本不匹配\n\n**解决方案**：\n\n1. 恢复备份的原始 libmpv-2.dll 文件\n2. 检查 CPU 指令集支持：\n   - Intel 4代及以上：可使用 V3 版本\n   - Intel 2-3代：仅可使用普通版本\n   - 更老的 CPU：无法使用此优化方案\n3. 重新下载库文件并验证完整性\n\n## 获取日志\n\n- 设置 → 开发者选项 → 终端输出：复制或导出日志；安卓/平板支持导出为二维码。\n- 提交 issue 时附带日志与平台信息、重现步骤。\n\n---\n\n**⬅️ 上一篇: [常见问题](#Documentation-faq)** | **➡️ 下一篇: [隐私与数据](#Documentation-privacy)**\n"
        },
        {
            "id": "Documentation-privacy",
            "name": "隐私与数据",
            "content": "# 隐私与数据\n\n- 本地播放记录与设置默认保存在本机。\n- 连接 Emby/Jellyfin 时，身份与媒体元数据在你的服务器端处理。\n- 日志用于排障，请在分享前检查是否包含敏感信息。\n\n---\n\n**⬅️ 上一篇: [故障排查](#Documentation-troubleshooting)** | **➡️ 下一篇: [更新与发布](#Documentation-release-channels)**\n"
        },
        {
            "id": "Documentation-release-channels",
            "name": "更新与发布通道",
            "content": "# 更新与发布通道\n\n- GitHub Releases：获取稳定版与历史版本。\n- macOS：推荐使用 Homebrew（tap + cask）进行安装与更新。\n- Arch Linux：使用 AUR 包 nipaplay-reload-bin。\n- 其他平台：关注发布页说明。\n\n---\n\n**⬅️ 上一篇: [隐私与数据](#Documentation-privacy)** | **🏠 返回首页: [欢迎来到 NipaPlay 文档](#Documentation-index)**\n"
        }
    ],
    "contributing_guide": [
        {
            "id": "CONTRIBUTING_GUIDE-00-Introduction",
            "name": "欢迎来到 NipaPlay-Reload 贡献指南",
            "content": "# 欢迎来到 NipaPlay-Reload 贡献指南\n\n你好，未来的贡献者！\n\n非常感谢你对 NipaPlay-Reload 项目感兴趣，并愿意贡献自己的一份力量。本指南旨在帮助你顺利地参与到项目中来，无论你是否具备编程经验。\n\n## 项目简介\n\nNipaPlay-Reload 是一个功能强大的视频播放器，旨在提供流畅、美观且高度可定制的观影体验。我们的目标是打造一个跨平台的、开源的、社区驱动的播放器，让每个人都能享受到最好的观影乐趣。\n\n## 本指南的目标\n\n我们相信，每个人都可以为开源社区做出贡献。编写这套文档的核心目的，就是为了**让不会编程、不熟悉 Flutter 和 Dart 语言的朋友，也能够借助现代化的人工智能（AI）编程工具（如 Cursor, Gemini, Claude 等）来为项目贡献代码**。\n\n本指南将为你提供清晰的、一步一步的指导，从环境搭建到代码提交，涵盖了整个贡献流程。我们会用通俗易懂的语言，配上具体的例子，让你能够轻松上手。\n\n## 文档结构\n\n为了让你能够循序渐进地学习，我们将指南分成了以下几个部分：\n\n### 入门篇\n*   **[0. 欢迎来到 NipaPlay-Reload 贡献指南](#CONTRIBUTING_GUIDE-00-Introduction)**: 了解项目愿景和贡献指南的整体结构。\n*   **[1. 准备你的开发环境](#CONTRIBUTING_GUIDE-01-Environment-Setup)**: 指导你如何在你的电脑上安装和配置所有必要的软件。\n*   **[2. 探索项目结构](#CONTRIBUTING_GUIDE-02-Project-Structure)**: 带你熟悉项目的代码文件是如何组织的，让你知道去哪里找东西、改东西。\n\n### 基础贡献流程\n*   **[3. 贡献代码的标准流程](#CONTRIBUTING_GUIDE-03-How-To-Contribute)**: 详细讲解使用 Git 和 GitHub 提交代码的流程，以及如何与 AI 工具协作。\n*   **[4. 代码风格指南](#CONTRIBUTING_GUIDE-04-Coding-Style)**: 介绍一些简单的代码编写规则，以保持项目代码的整洁和一致。\n*   **[5. 实战教程：添加一个\"贡献者名单\"页面](#CONTRIBUTING_GUIDE-05-Example-Add-A-New-Page)**: 通过一个完整的实例，手把手教你如何为应用添加一个新功能。\n*   **[6. 常见问题解答 (FAQ)](#CONTRIBUTING_GUIDE-06-FAQ)**: 汇总了贡献过程中可能会遇到的问题和解决方案。\n\n### 进阶主题\n*   **[7. 如何开发主题和自定义样式](#CONTRIBUTING_GUIDE-07-Theme-Development)**: 学习如何为应用添加新的视觉主题和自定义样式。\n*   **[8. (进阶) 如何添加新的播放器内核](#CONTRIBUTING_GUIDE-08-Adding-a-New-Player-Kernel)**: 学习如何为应用集成新的视频播放器。\n*   **[9. (进阶) 如何添加新的弹幕内核](#CONTRIBUTING_GUIDE-09-Adding-a-New-Danmaku-Kernel)**: 学习如何接入新的弹幕源或创建新的渲染器。\n*   **[10. (进阶) 如何进行平台特定开发](#CONTRIBUTING_GUIDE-10-Platform-Specific-Development)**: 学习如何编写和测试针对特定操作系统的功能。\n\n### 非技术贡献\n*   **[11. 非代码贡献：同样重要！](#CONTRIBUTING_GUIDE-11-Non-Coding-Contributions)**: **不擅长编程？没问题！** 这里介绍了你可以通过哪些同样重要的方式来帮助项目成长。\n\n## 准备好了吗？\n\n我们非常期待你的加入！请从下一篇文档《01-环境设置.md》开始你的贡献之旅吧。如果你在任何步骤中遇到问题，都不要犹豫，随时向我们提问。\n\n让我们一起让 NipaPlay-Reload 变得更好！\n\n---\n\n**➡️ 下一篇: [1. 准备你的开发环境](#CONTRIBUTING_GUIDE-01-Environment-Setup)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-01-Environment-Setup",
            "name": "1. 准备你的开发环境",
            "content": "# 1. 准备你的开发环境\n\n在开始为 NipaPlay-Reload 贡献代码之前，你需要先在你的电脑上搭建好开发环境。这个过程就像是为你盖房子前准备好工具和地基一样。别担心，我们会一步一步地指导你完成。\n\n## 核心工具\n\n无论你使用什么操作系统（Windows, macOS 或 Linux），以下这些工具都是必须安装的。\n\n### 1.1 Git：代码的版本管理员\n\nGit 是一个版本控制系统，你可以把它想象成一个可以记录你每一次代码修改的“时光机”。通过 Git，我们可以轻松地协作，合并不同人做的修改。\n\n*   **如何安装**:\n    *   **Windows**: 访问 [git-scm.com](https://git-scm.com/download/win) 下载安装包，然后按照默认设置一路点击“下一步”即可。\n    *   **macOS**: 打开“终端”应用，输入 `git --version`。如果系统提示你安装命令行开发者工具，请点击“安装”按钮。或者，你也可以通过 [Homebrew](https://brew.sh/)（一个包管理器）来安装，命令是 `brew install git`。\n    *   **Linux**: 打开你的终端，根据你的发行版使用相应的命令：\n        *   Debian/Ubuntu: `sudo apt-get install git`\n        *   Fedora: `sudo dnf install git`\n        *   Arch Linux: `sudo pacman -S git`\n*   **安装后的初始化**\n    *   使用以下命令进行初始化，记得把[你的用户名]和[你的邮箱]替换成和你 GitHub 一致的信息\n        ```\n        git config --global user.name \"[你的用户名]\"\n        git config --global user.email [你的邮箱]\n        ```\n\n### 1.1.1 (可选) 图形化工具：GitHub Desktop\n\n对于不习惯使用命令行的朋友，GitHub Desktop 是一个不错的替代选择。\n\n*   **下载地址**: [desktop.github.com](https://desktop.github.com/)\n*   **优点**: 它提供了一个可视化的界面，让你可以通过点击按钮来完成克隆、提交、推送等操作，非常直观。\n*   **为什么我们优先推荐命令行**: 学习使用命令行（终端）是程序员的一项基本功。它非常强大和灵活，并且是所有图形化 Git 工具的基础。掌握了命令行，你就能更深刻地理解 Git 的工作原理，并在遇到复杂情况时更好地解决问题。\n*   **建议**: 你可以安装 GitHub Desktop 作为辅助，但在本指南中，我们所有的例子都将使用命令行来演示，以帮助你打下坚实的基础。\n\n### 1.2 Flutter SDK：构建应用的工具箱\n\nFlutter 是我们用来开发 NipaPlay-Reload 的框架，它允许我们用一套代码构建在不同平台（如手机、电脑、网页）上运行的应用。Flutter SDK (软件开发工具包) 就是包含了所有开发所需工具的集合。\n\n*   **如何安装**:\n    1.  访问 [Flutter 官网](https://flutter.dev/docs/get-started/install) 下载对应你操作系统的最新稳定版 SDK。\n    2.  将下载的压缩包解压到一个你喜欢的位置，例如 `C:\\flutter` (Windows) 或者 `~/development/flutter` (macOS/Linux)。**注意：不要把 Flutter SDK 放在需要管理员权限才能访问的目录**，比如 `C:\\Program Files\\`。\n    3.  配置环境变量：这一步是为了让你的电脑能够在任何地方都能找到并使用 Flutter 的命令。\n        *   **Windows**: 搜索“编辑系统环境变量”，打开后点击“环境变量”，在“用户变量”下的 \"Path\" 变量里，新建一个条目，值为你解压的 Flutter SDK 文件夹里的 `bin` 目录的完整路径 (例如 `C:\\flutter\\bin`)。\n        *   **macOS/Linux**: 打开终端，编辑你的 shell 配置文件（通常是 `~/.zshrc`, `~/.bash_profile` 或 `~/.bashrc`）。在文件末尾添加一行：`export PATH=\"$PATH:[你解压的Flutter路径]/flutter/bin\"`。保存文件后，执行 `source ~/.zshrc` (或者相应的配置文件) 来让改动生效。\n    4.  运行 `flutter doctor`：打开一个新的终端窗口，输入 `flutter doctor` 命令。这个命令会检查你的环境是否完整，并告诉你还需要安装哪些依赖（比如 Android Studio 或者 Xcode）。根据它的提示完成剩余的设置。\n\n### 1.3 一个好的代码编辑器\n\n代码编辑器是你编写和修改代码的地方。一个好的编辑器能让你事半功倍。我们强烈推荐使用 **Cursor**，因为它深度集成了 AI 功能，可以极大地帮助你理解和编写代码。\n\n*   **Cursor**:\n    *   **下载地址**: [cursor.sh](https://cursor.sh/)\n    *   **为什么推荐它**: Cursor 可以让你直接在编辑器里与 AI 对话，比如让它帮你解释一段代码、生成新的代码片段，或者帮你修复错误。这对于编程新手来说是极大的助力。\n    *   **备选方案**: 如果你不想使用 Cursor，**Visual Studio Code (VS Code)** 或由社区构建的完全自由版本 **VSCodium** 也是一个非常优秀的选择。你可以通过安装 Flutter 和 Dart 插件来获得良好的开发体验，并通过安装相关插件（如 Goodcode）获得 AI 支持。\n\n## 获取项目代码\n\n环境准备好之后，最后一步就是把 NipaPlay-Reload 的代码克隆（下载）到你的本地电脑上。\n\n1.  **Fork 项目**:\n    *   首先，你需要在 GitHub 上有一个自己的账号。\n    *   访问 [NipaPlay-Reload 的 GitHub 仓库页面](https://github.com/MCDFsteve/NipaPlay-Reload)。\n    *   点击页面右上角的 \"Fork\" 按钮。这会在你的 GitHub 账号下创建一个项目的完整副本。\n\n2.  **克隆你的 Fork**:\n    *   打开你的终端。\n    *   导航到一个你希望存放项目的文件夹，例如 `cd ~/dev`。\n    *   执行以下命令，记得把 `[你的GitHub用户名]` 替换成你自己的用户名：\n        ```\n        git clone https://github.com/[你的GitHub用户名]/NipaPlay-Reload.git\n        ```\n    *   然后进入项目目录：\n        ```\n        cd NipaPlay-Reload\n        ```\n\n## 总结\n\n现在，你的电脑上已经拥有了开发 NipaPlay-Reload 所需的一切！你已经安装了 Git 和 Flutter，配置好了编辑器，并且下载了项目的代码。\n\n在下一章节，我们将带你了解项目的代码结构，让你知道不同的功能分别是在哪些文件里实现的。\n\n---\n\n**⬅️ 上一篇: [欢迎来到 NipaPlay-Reload 贡献指南](#CONTRIBUTING_GUIDE-00-Introduction)** | **➡️ 下一篇: [2. 探索项目结构](#CONTRIBUTING_GUIDE-02-Project-Structure)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-02-Project-Structure",
            "name": "2. 探索项目结构",
            "content": "# 2. 探索项目结构\n\n欢迎来到 NipaPlay-Reload 的代码世界！第一次看到这么多文件和文件夹可能会让你感到有些困惑，但这很正常。本章节将像一张地图，带你了解项目中最重要的部分，让你知道哪里是做什么的。\n\n当你用 Cursor 或 VS Code 打开项目后，你会在左侧看到项目的文件树。我们主要关心的是 `lib` 文件夹，因为我们应用绝大部分的核心代码都在这里。\n\n## `lib` 文件夹：应用的核心\n\n`lib` 文件夹是所有 Dart 代码的家。你可以把它想象成一座大厦的设计蓝图和功能模块所在。下面我们来看看里面的一些关键子文件夹：\n\n*   `lib/`\n    *   `main.dart`: 这是整个应用的入口文件，就像是房子的总开关。程序从这里开始运行。\n    *   `pages/`: 这个文件夹存放了应用中所有的“页面”或“屏幕”。比如，主页、设置页、视频详情页等，每一个页面的代码都在这里。如果你想修改某个页面的外观或者添加新页面，来这里就对了。\n    *   `widgets/`: “Widget”是 Flutter 中构建用户界面的基本单元，可以理解为一个个小的“零件”，比如按钮、卡片、列表项等。我们将一些通用的、可复用的零件放在这里，方便在不同页面中调用。\n    *   `models/`: 这个文件夹存放了应用的数据结构定义。比如，一个视频可能包含标题、封面图片地址、时长等信息，我们就会在这里定义一个“视频模型”来描述这些数据。\n    *   `controllers/` 或 `providers/`: 这里存放的是应用的“大脑”，负责处理业务逻辑。比如，当用户点击“播放”按钮后，具体执行加载视频、更新播放状态等操作的代码就在这里。它们是连接用户界面 (`pages/`) 和数据 (`models/`) 的桥梁。\n    *   `services/`: 用于处理与外部世界的交互，比如从网络API获取视频数据、读写本地文件等。所有“脏活累活”都交给它们。\n    *   `utils/`: 存放一些通用的工具类或函数，比如日期格式化、颜色定义等，方便在项目的任何地方使用。\n\n### 一个简单的例子\n\n假设我们想修改主页上视频卡片的显示样式。根据上面的介绍，你应该能猜到修改的流程：\n\n1.  首先，我们会在 `pages/` 里面找到主页对应的文件，比如 `dashboard_home_page.dart`。\n2.  在主页文件里，我们会看到它可能引用了一个通用的视频卡片“零件”，这个零件可能定义在 `widgets/` 文件夹下的某个文件里，比如 `anime_card.dart`。\n3.  打开 `anime_card.dart`，我们就可以修改它的布局、颜色、字体大小等样式了。\n4.  这个卡片显示的数据（如视频标题）是从哪里来的呢？它很可能是通过一个在 `models/` 中定义的“视频模型”传递过来的。\n\n通过这个例子，你应该对代码的组织方式有了初步的了解。\n\n## 其他重要文件夹\n\n除了 `lib` 之外，还有一些文件夹你也需要了解：\n\n*   `assets/`: 存放应用需要用到的静态资源，比如图片、图标、字体文件等。如果你想给应用换个 Logo，图片文件就放在这里。\n*   `android/` 和 `ios/`: 这两个文件夹分别包含了构建 Android 和 iOS 应用所需的原生平台代码。通常情况下，你不需要修改这里面的东西，除非你需要添加一些需要原生平台支持的特殊功能。\n*   `pubspec.yaml`: 这是 Flutter 项目的配置文件，非常重要。它列出了项目的所有依赖项（比如用到的第三方库）、应用的版本号、名称等信息。当你需要添加一个新的功能库时，就需要编辑这个文件。\n\n## 如何利用 AI 工具来辅助理解？\n\n当你对某一段代码感到困惑时，别忘了你的 AI 助手！在 Cursor 编辑器中，你可以：\n\n1.  **选中一段代码**：选中你看不懂的函数、变量或者一整个文件。\n2.  **按下 `Cmd + K` (macOS) 或 `Ctrl + K` (Windows/Linux)**。\n3.  **在弹出的输入框中提问**：“请用中文解释这段代码是做什么的？”或者“这个函数在什么场景下会被调用？”。\n\nAI 会给你一个详细的解释，帮助你快速理解代码的意图和逻辑。这是学习和贡献代码的强大武器。\n\n## 总结\n\n现在你已经对 NipaPlay-Reload 的项目结构有了基本的认识。记住，最重要的代码都在 `lib` 文件夹中。当你接到一个任务，比如“在设置页面增加一个选项”，你首先就应该去 `lib/pages/settings/` 目录下寻找相关文件。\n\n在下一章节，我们将正式开始讲解如何进行一次完整的代码贡献流程。\n\n---\n\n**⬅️ 上一篇: [1. 准备你的开发环境](#CONTRIBUTING_GUIDE-01-Environment-Setup)** | **➡️ 下一篇: [3. 贡献代码的标准流程](#CONTRIBUTING_GUIDE-03-How-To-Contribute)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-03-How-To-Contribute",
            "name": "3. 贡献代码的标准流程",
            "content": "# 3. 贡献代码的标准流程\n\n现在，你已经准备好了一切，是时候开始动手贡献代码了！本章将详细介绍从开始修改到提交代码的完整流程。这个流程是开源社区的标准做法，掌握它对你未来参与任何开源项目都大有裨益。\n\n我们将整个流程分为以下几个步骤：\n\n0. Fork 仓库并克隆到本地（设置 upstream）\n1. 创建并切换到一个新的分支 (Branch)\n2. 编写代码（在 AI 的帮助下）\n3. 提交你的修改 (Commit)\n4. 将你的分支推送到 GitHub (Push)\n5. 创建一个拉取请求 (Pull Request)\n\n听起来可能有点复杂，但别担心，我们会用一个具体的例子带你走完整个流程。\n\n## 我们的任务：在“关于”页面添加你的名字\n\n为了演示，我们来完成一个简单的任务：**在应用的“关于”页面里，加上一行“由 [你的名字] 贡献”的文本**。\n\n### 第 0 步：Fork 并克隆仓库（一次性准备）\n\n标准开源协作流程建议先 Fork 官方仓库到你的 GitHub 账号，然后克隆你的 Fork 到本地，并把官方仓库设置为 `upstream`：\n\n1. 在 GitHub 上打开官方仓库：[MCDFsteve/NipaPlay-Reload](https://github.com/MCDFsteve/NipaPlay-Reload)\n2. 点击右上角的 Fork，将其 Fork 到你的账号下。\n3. 克隆你的 Fork 到本地，并进入项目目录：\n\n    ```bash\n    git clone https://github.com/<你的用户名>/NipaPlay-Reload.git\n    cd NipaPlay-Reload\n    ```\n\n4. 添加官方仓库为上游（upstream）：\n\n    ```bash\n    git remote add upstream https://github.com/MCDFsteve/NipaPlay-Reload.git\n    git remote -v  # 可选：检查 remotes，通常 origin 指向你的 Fork，upstream 指向官方仓库\n    ```\n\n完成以上一次性准备后，后续开发都在你本地的这个仓库进行：`origin` 指你的 Fork，`upstream` 指官方仓库。\n\n### 第 1 步：创建和切换分支\n\n在动手修改代码之前，**永远不要直接在 `main` 或 `master` 分支上进行修改**。这是一个非常重要的原则。我们应该为每一个新功能或修复创建一个新的“分支”。\n\n分支可以理解为代码库的一个独立副本，你在上面的修改不会影响到主干（`main` 分支）。\n\n1. **确保你的本地代码是最新的**:\n    在开始前，先从官方仓库同步最新的代码，确保你的 `main` 分支与 `upstream/main` 保持一致。\n\n    ```bash\n    # 首先，确保你在 main 分支\n    git checkout main\n\n    # 获取上游最新提交\n    git fetch upstream\n\n    # 将本地 main 同步到 upstream/main（二选一，推荐 rebase 保持线性历史）\n    git rebase upstream/main\n    # 或者\n    # git merge upstream/main\n\n    # 可选：把同步后的 main 推送回你的 Fork\n    git push origin main\n    ```\n\n2. **创建新分支**:\n    打开终端，在你的项目文件夹根目录下，运行以下命令：\n\n    ```bash\n    git checkout -b feat/add-contributor-name-to-about-page\n    ```\n\n    这条命令做了两件事：\n    * `git checkout -b`: 创建一个新分支。\n    * `feat/add-contributor-name-to-about-page`: 这是我们给新分支取的名字。一个好的分支名应该能清晰地描述这个分支是做什么的。\n\n    现在，你已经在这个全新的分支上了，可以安全地进行修改了。\n\n### 第 2 步：与 AI 一起编写代码\n\n现在，我们要找到“关于”页面的代码文件，并添加我们的文本。\n\n1. **定位文件**:\n    根据我们在上一章学到的知识，页面相关的代码应该在 `lib/pages/` 目录下。我们可以在 `lib/pages/settings/` 中找到一个名为 `about_page.dart` 的文件。\n\n2. **向 AI 求助**:\n    打开 `about_page.dart` 文件。现在，我们不需要自己去读懂所有代码。我们可以直接让 AI 帮我们完成任务。\n    在 Cursor 中，选中整个文件的代码 (Cmd+A 或 Ctrl+A)，然后按下 `Cmd+K` (或 Ctrl+K)，在弹出的对话框中输入我们的需求：\n\n    > “请在这个页面的 `build` 方法里，找到合适的位置，在应用版本号下面，添加一个 `Text` 组件，内容是‘由 [你的名字] 贡献’。请把 [你的名字] 替换成 MCDF。”\n\n    AI 会分析代码，并给出修改建议。它可能会生成类似下面这样的代码片段：\n\n    ```dart\n    // ... 原有的代码 ...\n    Text('Version: ${packageInfo.version}'),\n    const SizedBox(height: 8), // 可能是 AI 帮你加的间距\n    const Text('由 MCDF 贡献'), // 这是 AI 帮你添加的代码\n    // ... 其他原有代码 ...\n    ```\n\n3. **应用修改**:\n    仔细看一下 AI 给出的修改方案，如果看起来没问题，就接受它。现在，你的代码就已经修改好了！\n\n4. **运行和测试**:\n    在终端里运行 `flutter run`，启动应用，然后导航到“设置” -> “关于”页面，看看你的名字是不是已经显示在上面了。确认无误后，我们就可以进行下一步了。\n\n### 第 3 步：提交你的修改 (Commit)\n\n代码修改完成后，我们需要把它“提交”到我们本地的 Git 仓库里。Commit 可以理解为给你的代码拍一张快照，并附上一句说明。\n\n1. **查看状态**:\n\n    ```bash\n    git status\n    ```\n\n    这个命令会告诉你哪些文件被修改了。你应该能看到 `lib/pages/settings/about_page.dart` 出现在列表中。\n\n2. **暂存文件**:\n\n    ```bash\n    git add lib/pages/settings/about_page.dart\n    ```\n\n    这个命令告诉 Git，我们希望把这个文件的修改包含在下一次提交中。如果你修改了多个文件，可以多次使用 `git add`。\n\n3. **提交**:\n\n    ```bash\n    git commit -m \"feat: Add contributor name to about page\"\n    ```\n\n    * `git commit`: 执行提交操作。\n    * `-m`: 表示后面跟着的是提交信息。\n    * `\"feat: Add contributor name to about page\"`: 这是提交信息，非常重要。一个好的提交信息应该清晰地描述这次提交做了什么。我们通常使用一种格式，比如 `feat:` 表示新增功能，`fix:` 表示修复 bug。\n        >   更多有关提交信息的规范可以参考[约定式提交](https://www.conventionalcommits.org/zh-hans/v1.0.0/)\n\n### 第 4 步：推送到 GitHub (Push)\n\n现在，这个提交只存在于你的本地电脑上。我们需要把它推送到你在 GitHub 上的 Fork 仓库。\n\n```bash\ngit push origin feat/add-contributor-name-to-about-page\n```\n\n*   `git push`: 执行推送操作。\n*   `origin`: 代表你在 GitHub 上的 Fork 仓库。\n*   `feat/add-contributor-name-to-about-page`: 我们要推送的分支名。\n* `git push`: 执行推送操作。\n* `origin`: 代表你在 GitHub 上的 Fork 仓库。\n* `add-my-name-to-about-page`: 我们要推送的分支名。\n\n### 第 5 步：创建拉取请求 (Pull Request)\n\n最后一步！Pull Request (PR) 是一个请求，请求项目维护者将你分支里的代码合并到主干（`main` 分支）里去。\n\n1. 打开你在 GitHub 上的 Fork 仓库页面 (`https://github.com/[你的用户名]/NipaPlay-Reload`)。\n2. GitHub 会自动检测到你刚刚推送了一个新分支，并显示一个黄色的提示条，上面有一个 \"Compare & pull request\" 按钮。点击它。\n3. 在 PR 页面确认合并目标：\n    * base repository：`MCDFsteve/NipaPlay-Reload`，base：`main`\n    * head repository：`[你的用户名]/NipaPlay-Reload`，compare：你刚推送的分支，例如 `add-my-name-to-about-page`\n4. 你会进入一个新的页面。请在这里填写 PR 的标题和描述。\n    * **标题**: 通常使用你的 commit 信息即可，例如 \"feat: Add contributor name to about page\"。\n    * **描述**: 详细说明你做了什么修改，为什么要做这个修改。如果这个修改解决了某个 Issue，可以在这里链接它 (例如 `Closes #123`)。\n5. 点击 \"Create pull request\" 按钮。\n\n## 恭喜你\n\n你已经成功地提交了你的第一个代码贡献！现在，项目维护者会收到通知，他们会审查你的代码 (Code Review)，可能会提出一些修改建议。你可以和他们在 PR 页面进行讨论。一旦你的代码被批准，他们就会把它合并到主项目中。\n\n这个流程一开始可能会觉得有些繁琐，但多操作几次就会变得非常熟悉。记住，大胆地去尝试，AI 会是你最得力的助手。\n\n---\n\n**⬅️ 上一篇: [2. 探索项目结构](#CONTRIBUTING_GUIDE-02-Project-Structure)** | **➡️ 下一篇: [4. 代码风格指南](#CONTRIBUTING_GUIDE-04-Coding-Style)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-04-Coding-Style",
            "name": "4. 代码风格指南",
            "content": "# 4. 代码风格指南\n\n为了让 NipaPlay-Reload 的代码库保持整洁、可读和易于维护，我们约定了一些简单的代码风格规则。当你贡献代码时，请尽量遵守这些指南。\n\n好消息是，你不需要手动记住所有规则。Flutter 自带了强大的工具来帮助我们自动格式化代码和检查问题。\n\n## 首要原则：自动化工具优先\n\n我们强烈依赖自动化工具来保证代码风格的一致性。\n\n### 1. 使用 `dart format`\n\n在你提交代码之前，请务必在项目根目录运行以下命令：\n\n```bash\ndart format .\n```\n\n这个命令会自动格式化你所有的 Dart 代码文件，使其符合官方推荐的风格。这包括处理缩进、空格、逗号等所有细节。\n\n**与 AI 协作时的技巧**: 当 AI 生成了大量代码后，你可能会发现代码的格式有点乱。别担心，直接运行 `dart format .`，所有问题都会迎刃而解。\n\n### 2. 关注 `flutter analyze`\n\n除了格式化，我们还使用静态分析工具来捕捉潜在的代码问题。运行以下命令：\n\n```bash\nflutter analyze\n```\n\n这个工具会检查你的代码，并报告任何警告或错误，比如未使用的变量、不符合规范的命名等。在提交 Pull Request 之前，请尽量确保这个命令没有报告任何新的问题。\n\n## 核心编码约定\n\n虽然自动化工具能解决大部分问题，但还有一些约定需要我们共同遵守。\n\n### 1. 命名规范\n\n清晰的命名是代码可读性的关键。\n\n*   **文件名**: 使用 `snake_case` (小写字母和下划线)。例如：`user_profile_page.dart`。\n*   **类名、枚举名**: 使用 `UpperCamelCase` (大驼峰命名法)。例如：`class UserProfile`。\n*   **变量名、函数名、参数名**: 使用 `lowerCamelCase` (小驼峰命名法)。例如：`String userName`，`void getUserProfile()`。\n*   **常量**: 使用 `lowerCamelCase`。例如：`const int maxRetryCount = 3`。\n\n**示例**:\n```dart\n// 好例子\nclass UserProfilePage extends StatelessWidget {\n  final String userId;\n\n  const UserProfilePage({super.key, required this.userId});\n\n  Future<void> fetchUserData() async {\n    // ...\n  }\n}\n\n// 坏例子\nclass user_profile_page extends StatelessWidget { // 应该用 UpperCamelCase\n  String User_Id; // 应该用 lowerCamelCase\n\n  void Get_User_Data(){ // 应该用 lowerCamelCase\n    // ...\n  }\n}\n```\n\n### 2. 注释\n\n代码本身应该尽可能地自解释。但对于复杂的逻辑，注释是必要的。\n\n*   **为什么这么做，而不是在做什么**: 好的注释解释的是代码背后的“为什么”，而不是简单地复述代码“在做什么”。\n*   **使用 `//` 进行单行注释**。\n*   **使用 `///` 为公共 API (类、函数) 编写文档注释**。\n\n**示例**:\n```dart\n// 坏例子: 这个注释是多余的\n// 增加计数器的值\ncounter++;\n\n// 好例子: 解释了为什么需要这个检查\n// 我们需要在这里检查用户是否为空，\n// 因为用户数据可能在另一个异步操作中被清除了。\nif (user != null) {\n  // ...\n}\n\n/// 获取指定用户的个人资料。\n///\n/// 如果用户不存在，会抛出一个 [UserNotFoundException]。\nFuture<User> getUserById(String id) async {\n  // ...\n}\n```\n\n### 3. 代码结构\n\n*   **保持函数短小**: 一个函数应该只做一件事情。如果一个函数过于庞大，考虑将它拆分成几个更小的、逻辑清晰的辅助函数。\n*   **优先使用 `const`**: 如果一个变量或组件在编译时其值就是确定的，请务必使用 `const` 关键字。这有助于提升应用的性能。Flutter 的分析工具通常会提示你这样做。\n\n## 让 AI 帮你遵守规范\n\n当你使用 AI 生成代码时，可以主动提出要求，让它遵守我们的代码风格。\n\n**示例提示**:\n\n> “请帮我创建一个 Flutter 页面，用于显示用户列表。请确保所有变量和函数都使用 `lowerCamelCase` 命名，并为主要的类和函数添加文档注释。”\n\n通过在提示中加入风格要求，你可以从一开始就获得更高质量、更符合项目规范的代码。\n\n## 总结\n\n遵守代码风格指南有助于我们共同维护一个健康的代码库。记住，最重要的两点是：\n\n1. 在提交前运行 `dart format .`。\n2. 尽量解决 `flutter analyze` 报告的问题。\n\n感谢你为保持 NipaPlay-Reload 代码的优雅和清晰所做的努力！\n\n---\n\n**⬅️ 上一篇: [3. 贡献代码的标准流程](#CONTRIBUTING_GUIDE-03-How-To-Contribute)** | **➡️ 下一篇: [5. 实战教程：添加一个“贡献者名单”页面](#CONTRIBUTING_GUIDE-05-Example-Add-A-New-Page)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-05-Example-Add-A-New-Page",
            "name": "5. 实战教程：添加一个“贡献者名单”页面",
            "content": "# 5. 实战教程：添加一个“贡献者名单”页面\n\n理论学完了，现在是动手实践的时候了！本章将通过一个完整的例子，手把手带你为 NipaPlay-Reload 添加一个全新的页面。\n\n**我们的目标**: 创建一个名为“贡献者名单”的新页面，并在设置页面添加入口，点击后可以跳转到这个新页面。这个页面上会显示一份为项目做出贡献的人员列表。\n\n我们将严格按照之前的流程，并重点展示如何与 AI 高效协作。\n\n### 第 1 步：创建新分支\n\n和之前一样，为我们的新功能创建一个描述清晰的分支。\n\n```bash\ngit checkout -b feat/add-contributors-page\n```\n\n### 第 2 步：构思与规划 (与 AI 对话)\n\n在开始写代码之前，我们可以先和 AI 沟通我们的想法，让它帮我们规划。\n\n打开 Cursor，我们可以创建一个新的空白文件，或者在任意地方打开聊天窗口 (`Cmd/Ctrl + L`)，然后向 AI 提问：\n\n> “你好，我正在为一个基于 Flutter 的项目 NipaPlay-Reload 贡献代码。我想添加一个名为‘贡献者名单’ (ContributorsPage) 的新页面。\n>\n> 页面要求如下：\n> 1. 这是一个无状态的 `StatelessWidget`。\n> 2. 页面顶部有一个标题，显示‘鸣谢’。\n> 3. 页面主体是一个列表，用来显示贡献者的名字和他们的 GitHub 主页链接。\n> 4. 现在，请先用一个硬编码的（写死的）贡献者列表作为示例数据，比如：\n>    - 姓名: MCDFsteve, 链接: https://github.com/MCDFsteve\n>    - 姓名: Contributor2, 链接: https://github.com/contributor2\n> 5. 列表中的每一项都要美观，并且可以点击，点击后能在浏览器中打开对应的 GitHub 链接。\n>\n> 请帮我生成这个页面的完整 Dart 代码。请将代码放在一个名为 `contributors_page.dart` 的新文件里。另外，请使用 `url_launcher` 这个库来打开链接，如果代码中用到了，记得提醒我需要添加这个依赖。”\n\nAI 会理解你的需求，并生成一份完整的代码文件。这比我们自己从零开始写要快得多。\n\n### 第 3 步：创建文件并应用代码\n\n1.  **创建文件**: 在 `lib/pages/settings/` 目录下，创建一个新文件，命名为 `contributors_page.dart`。\n2.  **粘贴代码**: 将 AI 生成的代码完整地粘贴到这个新文件中。\n\nAI 生成的代码可能类似这样：\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:url_launcher/url_launcher.dart';\n\nclass Contributor {\n  final String name;\n  final String githubUrl;\n\n  const Contributor({required this.name, required this.githubUrl});\n}\n\nclass ContributorsPage extends StatelessWidget {\n  const ContributorsPage({super.key});\n\n  final List<Contributor> contributors = const [\n    Contributor(name: 'MCDFsteve', githubUrl: 'https://github.com/MCDFsteve'),\n    Contributor(name: 'Contributor2', githubUrl: 'https://github.com/contributor2'),\n    // 在这里添加更多的贡献者\n  ];\n\n  Future<void> _launchURL(String url) async {\n    final Uri uri = Uri.parse(url);\n    if (!await launchUrl(uri)) {\n      throw 'Could not launch $url';\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('鸣谢'),\n      ),\n      body: ListView.builder(\n        itemCount: contributors.length,\n        itemBuilder: (context, index) {\n          final contributor = contributors[index];\n          return ListTile(\n            title: Text(contributor.name),\n            subtitle: Text(contributor.githubUrl),\n            onTap: () => _launchURL(contributor.githubUrl),\n            trailing: const Icon(Icons.open_in_new),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n### 第 4 步：处理依赖\n\nAI 提醒我们用到了 `url_launcher` 库。这是一个第三方库，需要先添加到项目中才能使用。\n\n1.  **添加依赖**: 打开终端，运行以下命令：\n    ```bash\n    flutter pub add url_launcher\n    ```\n    这个命令会自动将 `url_launcher` 添加到你的 `pubspec.yaml` 文件中。\n\n### 第 5 步：添加入口 (再次与 AI 协作)\n\n新页面创建好了，但现在应用里还没有地方可以进入这个页面。我们需要在设置页面添加一个入口。\n\n1.  **定位文件**: 打开 `lib/pages/settings/settings_page.dart` (或者类似的设置页面文件)。\n2.  **向 AI 提问**: 选中整个文件的代码，按下 `Cmd/Ctrl + K`，然后输入：\n\n    > “这是我的设置页面代码。请在‘关于’选项的旁边，添加一个新的列表项，文本是‘贡献者名单’。当用户点击这个列表项时，请导航到我们刚刚创建的 `ContributorsPage`。记得帮我导入 `contributors_page.dart` 文件。”\n\nAI 会帮你找到合适的位置，并添加类似下面的代码：\n\n```dart\n// ... 在文件顶部，AI 会帮你添加导入语句\nimport 'contributors_page.dart';\n\n// ... 在 build 方法的某个位置 ...\nListTile(\n  leading: const Icon(Icons.people),\n  title: const Text('贡献者名单'),\n  onTap: () {\n    Navigator.push(\n      context,\n      MaterialPageRoute(builder: (context) => const ContributorsPage()),\n    );\n  },\n),\nListTile( // 原有的“关于”选项\n  leading: const Icon(Icons.info_outline),\n  title: const Text('关于'),\n  // ...\n),\n```\n\n### 第 6 步：测试和格式化\n\n1.  **运行应用**: 在终端运行 `flutter run`。\n2.  **测试功能**: 导航到“设置”页面，你应该能看到新增的“贡献者名单”选项。点击它，应该能成功跳转到新页面。再点击页面上的任意一个贡献者，应该能用浏览器打开对应的 GitHub 链接。\n3.  **格式化代码**: 在提交前，别忘了运行格式化命令。\n    ```bash\n    flutter format .\n    ```\n\n### 第 7 步：提交和创建 Pull Request\n\n所有功能都正常工作后，我们就可以提交代码了。\n\n1.  **暂存所有修改**:\n    ```bash\n    git add .\n    ```\n    (这里的 `.` 代表所有被修改过的文件)\n\n2.  **提交**:\n    ```bash\n    git commit -m \"feat: Add contributors page\"\n    ```\n\n3.  **推送**:\n    ```bash\n    git push origin feat/add-contributors-page\n    ```\n\n4.  **创建 Pull Request**:\n    去你的 GitHub Fork 仓库页面，点击 \"Compare & pull request\" 按钮，填写好标题和描述，然后提交。\n\n## 总结\n\n恭喜你！你刚刚独立（在 AI 的帮助下）为项目添加了一个完整的新功能！\n\n通过这个例子，你可以看到，即使你不完全理解每一行代码的细节，只要你能清晰地向 AI 描述你的需求，就能完成很多有意义的贡献。随着你做得越来越多，你对代码的理解也会自然而然地加深。\n\n---\n\n**⬅️ 上一篇: [4. 代码风格指南](#CONTRIBUTING_GUIDE-04-Coding-Style)** | **➡️ 下一篇: [6. 常见问题解答 (FAQ)](#CONTRIBUTING_GUIDE-06-FAQ)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-06-FAQ",
            "name": "6. 常见问题解答 (FAQ)",
            "content": "# 6. 常见问题解答 (FAQ)\n\n在你的贡献之旅中，可能会遇到一些磕磕绊绊。别担心，这是每个开发者的必经之路。本章汇总了一些常见的问题和对应的解决方案，希望能帮助你顺利地解决它们。\n\n### Q1: 我运行 `flutter doctor` 时，有很多项都打着叉 (✗)，怎么办？\n\n**A:** `flutter doctor` 是一个诊断工具，它会检查你的 Flutter 开发环境是否完整。\n\n1.  **仔细阅读错误信息**: `flutter doctor` 会清晰地告诉你缺少了什么。比如，它可能会说 \"Android toolchain - develop for Android devices (Android SDK version 33.0.0)\"，这通常意味着你需要安装或更新 Android SDK。\n2.  **逐一解决**: 不要慌张，从上到下，一次解决一个问题。\n3.  **Android Studio/Xcode**: 大多数问题都和 Android Studio (用于 Android 开发) 或 Xcode (用于 iOS 开发) 的配置有关。请确保你已经根据 Flutter 官网的指引安装和配置好了它们。比如，在 Android Studio 中，你需要通过 SDK Manager 安装对应的 SDK 和命令行工具。对于 Xcode，你需要运行 `sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer` 并同意它的协议。\n4.  **向 AI 求助**: 如果你看不懂某条错误信息，可以直接复制它，然后询问你的 AI 助手：“我在运行 `flutter doctor` 时遇到了这个错误：‘[粘贴错误信息]’，请问我应该如何解决？”\n\n### Q2: 我提交 Pull Request 后，为什么会有“合并冲突” (Merge Conflict)？\n\n**A:** 合并冲突的发生，通常是因为在你开发新功能的同时，`main` 分支上也有了新的更新，而且这些更新和你修改了同一个文件的同一部分。\n\n**如何解决**:\n1.  **保持你的分支是新的**: 在准备提交 PR 之前，或者当你看到 GitHub 提示有冲突时，先将主分支的最新代码同步到你的分支。\n    ```bash\n    # 首先，确保你的 main 分支是最新的\n    git checkout main\n    git pull upstream main\n\n    # 然后，切换回你的功能分支\n    git checkout [你的分支名] # 比如 feat/add-contributors-page\n\n    # 将最新的 main 分支代码合并到你的分支\n    git merge main\n    ```\n2.  **手动解决冲突**: 运行 `git merge main` 后，如果存在冲突，Git 会在终端里提示你。同时，在你的代码编辑器里，冲突的文件会用特殊的标记（如 `<<<<<<<`, `=======`, `>>>>>>>`）标出。\n    *   你需要做的是，打开这些文件，手动决定要保留哪一部分代码（你的？还是 `main` 分支上的？或者两者结合？）。\n    *   删除掉 Git 添加的特殊标记行。\n3.  **再次向 AI 求助**: 如果你对如何选择代码感到困惑，可以把整个带有冲突标记的代码块复制给 AI，然后提问：“我遇到了 Git 合并冲突，请帮我分析下面的代码，并告诉我应该如何正确地合并它们。”\n4.  **完成合并**: 解决完所有冲突后，保存文件，然后执行：\n    ```bash\n    git add .\n    git commit -m \"fix: Merge main and resolve conflicts\"\n    git push origin [你的分支名]\n    ```\n    这样，你的 Pull Request 就会自动更新，冲突也就解决了。\n\n### Q3: AI 生成的代码在我这里运行不起来，报错了，怎么办？\n\n**A:** AI 虽强，但并非万能，它生成的代码有时也可能存在问题。\n\n1.  **阅读错误日志**: 首先，仔细查看终端或调试控制台里的错误信息。这是定位问题的最直接线索。\n2.  **“喂”给 AI**: 将完整的错误日志和导致错误的代码块一起提供给 AI，然后提问：“我使用了你生成的这段代码，但是运行时出现了这个错误，请帮我分析原因并修复它。”\n3.  **检查依赖**: 确认代码中用到的所有第三方库都已经在 `pubspec.yaml` 中声明，并且已经运行过 `flutter pub get`。\n4.  **检查 Flutter 版本**: 极少数情况下，AI 可能使用了较新版本 Flutter 才有的特性。你可以通过 `flutter --version` 查看你的版本，并告知 AI，让它生成兼容你版本的代码。\n\n### Q4: 我应该如何给我的 Pull Request 写一个好的描述？\n\n**A:** 一个好的 PR 描述能帮助项目维护者快速理解你的贡献。\n\n*   **关联 Issue**: 如果你的 PR 是为了解决某个特定的 Issue，请在描述中写上 `Closes #[Issue编号]`，例如 `Closes #42`。这样，当你的 PR 被合并后，对应的 Issue 会被自动关闭。\n*   **清晰说明“做了什么”**: 简要概括你这次修改的主要内容。例如：“新增了一个贡献者名单页面，并在设置页添加了入口。”\n*   **解释“为什么这么做”**: 如果适用，可以简单说明你这么做的原因。例如：“为了感谢社区的贡献者，并提供一个展示他们信息的平台。”\n*   **截图或录屏**: 如果你的修改涉及到用户界面的变化，强烈建议附上一张截图或一个简短的GIF动图，这能让审查者一目了然。\n\n如果你对上述任何问题还有疑问，或者遇到了新的问题，不要犹豫，请在项目的 GitHub Issue 区提出，我们很乐意帮助你！\n\n---\n\n**⬅️ 上一篇: [5. 实战教程：添加一个“贡献者名单”页面](#CONTRIBUTING_GUIDE-05-Example-Add-A-New-Page)** | **➡️ 下一篇: [7. 如何开发主题和自定义样式](#CONTRIBUTING_GUIDE-07-Theme-Development)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-07-Theme-Development",
            "name": "7. 如何开发主题和自定义样式",
            "content": "# 7. 如何开发主题和自定义样式\n\nNipaPlay-Reload 的一个核心魅力在于其美观且可定制的用户界面。本章将带你深入了解应用的主题系统，并教你如何利用项目独特的“神秘毛玻璃配方”来创建美观的 UI 组件，甚至添加一套全新的主题。\n\n## NipaPlay 主题的核心：神秘毛玻璃配方\n\n你可能已经注意到，NipaPlay 主题下的很多 UI 元素（如下拉菜单、对话框、按钮）都有一种半透明、带有模糊背景的“毛玻璃”质感。这赋予了应用一种轻盈、现代的感觉。\n\n这个效果的实现非常简单，你可以把它应用到任何自定义组件上。其核心配方是：\n\n*   **背景色**: `Colors.white.withOpacity(0.1)` (透明度为 10% 的纯白色)\n*   **模糊效果**: `GaussianBlur(sigmaX: 25, sigmaY: 25)` (25像素的高斯模糊)\n*   **边框**: `Border.all(color: Colors.white, width: 1)` (1像素粗细的纯白描边)\n\n### 如何在 Flutter 中实现它？\n\n要将这个效果应用到一个组件（Widget）上，我们通常会使用 `BackdropFilter` 和 `Container` 组件的组合。`BackdropFilter` 负责实现背景模糊，而 `Container` 负责背景色和边框。\n\n这是一个典型的“毛玻璃”容器的实现代码：\n\n```dart\nimport 'dart:ui'; // 需要导入 dart:ui 来使用 ImageFilter\n\n// ...\n\n// 使用 ClipRRect 来确保模糊效果不会“溢出”到容器的圆角之外\nClipRRect(\n  borderRadius: BorderRadius.circular(12.0), // 圆角大小\n  child: BackdropFilter(\n    filter: ImageFilter.blur(sigmaX: 25, sigmaY: 25), // 高斯模糊\n    child: Container(\n      decoration: BoxDecoration(\n        color: Colors.white.withOpacity(0.1), // 10% 透明度的白色背景\n        borderRadius: BorderRadius.circular(12.0),\n        border: Border.all(color: Colors.white, width: 1), // 1像素白色描边\n      ),\n      child: YourContentWidget(), // 在这里放入你的内容\n    ),\n  ),\n)\n```\n\n**与 AI 协作**:\n你可以直接把这段代码交给 AI，然后告诉它：“请帮我创建一个新的 Flutter Widget，让它使用这段代码作为背景，并在里面放置一个标题为‘你好世界’的文本。” AI 能很快帮你生成一个完整的、可用的毛玻璃风格组件。\n\n## 理解现有主题系统\n\n在动手创建新主题之前，我们先快速了解一下项目是如何管理主题的。\n\n1.  **UI 主题类型 (`ui_theme_provider.dart`)**: 这里定义了应用支持的几种主要 UI 风格，比如 `nipaplay` 和 `fluentUI`。如果你想添加一种全新的、截然不同的风格（比如“赛博朋克风”），你需要在这里添加一个新的枚举值。\n2.  **亮/暗模式主题 (`app_theme.dart`)**: 这个文件定义了 `ThemeData` 对象，包含了应用在亮色和暗色模式下的具体颜色、字体、按钮样式等。`lightTheme` 和 `darkTheme` 是关键。\n3.  **主题切换器 (`theme_notifier.dart` 和 `ui_theme_provider.dart`)**: 这两个 Provider (提供者) 负责监听用户的选择，切换主题，并将设置持久化保存到设备上。\n\n## 实战：为 NipaPlay 主题添加一个新的自定义按钮\n\n让我们来实践一下，创建一个遵循“毛玻璃配方”的新按钮。\n\n### 第 1 步：创建分支\n\n```bash\ngit checkout -b feat/add-glass-button\n```\n\n### 第 2 步：让 AI 生成基础组件\n\n向你的 AI 助手发出指令：\n\n> “请为我创建一个名为 `GlassButton` 的 Flutter `StatelessWidget`。\n> 1. 这个按钮需要一个 `String` 类型的 `text` 参数和一个 `VoidCallback` 类型的 `onPressed` 参数。\n> 2. 按钮的背景需要使用‘毛玻璃’效果：10%透明度的白色背景，25像素高斯模糊，1像素白色描边，圆角为 8。\n> 3. 按钮内部的文本颜色为白色。\n> 4. 当按钮被点击时，执行 `onPressed` 回调。\n> 5. 请将这个组件的代码放在 `lib/widgets/nipaplay_theme/` 目录下，文件名为 `glass_button.dart`。”\n\n### 第 3 步：应用和测试按钮\n\nAI 会为你生成 `glass_button.dart` 文件的完整代码。现在，我们可以尝试在某个页面使用它。\n\n1.  **定位页面**: 比如，我们可以打开 `lib/pages/settings/about_page.dart`。\n2.  **使用新按钮**: 在页面上找个合适的位置，添加你的新按钮：\n    ```dart\n    import 'package:nipaplay/widgets/nipaplay_theme/glass_button.dart'; // 别忘了导入\n\n    // ... 在 build 方法的某个位置 ...\n    GlassButton(\n      text: '这是一个毛玻璃按钮',\n      onPressed: () {\n        // 打印一条信息来测试点击事件\n        debugPrint('毛玻璃按钮被点击了!');\n      },\n    ),\n    ```\n3.  **运行测试**: 运行 `flutter run`，进入“关于”页面，你应该能看到一个漂亮的毛玻璃按钮，并且点击它时，控制台会输出信息。\n\n### 第 4 步：(进阶) 添加一个全新的主题\n\n如果你想挑战一下，可以尝试添加一个全新的主题。\n\n1.  **添加枚举**: 在 `lib/providers/ui_theme_provider.dart` 的 `UIThemeType` 枚举中，添加一个你的主题名，例如 `cyberpunk`。\n2.  **创建主题数据**: 模仿 `lib/utils/app_theme.dart`，为你`cyberpunk`主题创建一个新的 `ThemeData` 对象，定义一套全新的颜色和字体。\n3.  **创建 UI 组件**: 在 `lib/widgets/` 下创建一个 `cyberpunk_theme/` 文件夹，开始构建你新主题下的各种自定义组件。\n4.  **修改切换逻辑**: 在所有涉及到主题切换的 UI 页面（比如 `ui_theme_page.dart`）中，添加对你新主题的选项。\n5.  **更新 `main.dart`**: 在 `main.dart` 中，应用启动时会根据 `UIThemeProvider` 的状态来决定显示哪套 UI。你需要在这里加入一个 case，当主题是 `cyberpunk` 时，返回你创建的 `CyberpunkHomePage` (举例)。\n\n这个过程会更复杂，需要修改多个文件。当你进行这种大规模修改时，更要频繁地与 AI 对话，让它帮你定位文件、理解代码逻辑、生成新的代码片段。\n\n## 总结\n\n现在你已经掌握了 NipaPlay-Reload 界面设计的核心秘密，并学会了如何创建自定义组件和主题。发挥你的创造力，为项目带来更酷炫、更个性化的视觉体验吧！\n\n---\n\n**⬅️ 上一篇: [6. 常见问题解答 (FAQ)](#CONTRIBUTING_GUIDE-06-FAQ)** | **➡️ 下一篇: [8. (进阶) 如何添加新的播放器内核](#CONTRIBUTING_GUIDE-08-Adding-a-New-Player-Kernel)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-08-Adding-a-New-Player-Kernel",
            "name": "8. (进阶) 如何添加新的播放器内核",
            "content": "# 8. (进阶) 如何添加新的播放器内核\n\nNipaPlay-Reload 的核心优势之一是其灵活的播放器架构，它允许我们接入不同的播放器内核以适应不同平台或格式的需求。本章是一个进阶教程，旨在指导你如何为应用集成一个全新的播放器内核。\n\n这是一个具有挑战性但非常有价值的贡献。在开始之前，请确保你已经熟悉了前面章节介绍的所有基础贡献流程。\n\n## 播放器抽象层架构解析\n\n在动手编码前，理解我们是如何做到“可插拔”播放器的是至关重要的。核心思想在于**抽象**和**适配**。我们不让UI代码直接与某个具体的播放器SDK（如 MDK、MediaKit）对话，而是通过一个我们自己定义的“标准播放器接口”来沟通。\n\n请重点关注 `lib/player_abstraction/` 目录，这里的关键文件构成了我们的架构：\n\n1.  **`abstract_player.dart`**: 定义了 `AbstractPlayer` 接口。这是我们的“标准播放器蓝图”。它规定了一个播放器**必须**具备哪些能力（属性和方法），例如：\n    *   `playDirectly()` / `pauseDirectly()`: 控制播放和暂停。\n    *   `seek()`: 跳转到指定时间。\n    *   `volume`: 控制音量。\n    *   `playbackRate`: 控制播放速度。\n    *   `textureId`: （对于纹理渲染方式的播放器）提供渲染所需的纹理ID。\n    *   `state`: 报告当前的播放状态（播放、暂停、停止）。\n    *   `mediaInfo`: 提供媒体信息（时长、分辨率等）。\n    *   `dispose()`: 释放资源。\n\n2.  **播放器适配器 (Adapters)**: 目录下的 `mdk_player_adapter.io.dart`, `media_kit_player_adapter.dart` 等文件就是具体的“适配器”。它们的作用是：\n    *   实现 (`implements`) `AbstractPlayer` 接口。\n    *   在内部调用具体播放器SDK（例如 `package:media_kit`）的API。\n    *   将播放器SDK的特定功能和数据结构“翻译”成 `AbstractPlayer` 接口所要求的标准形式。\n    *   **每一个新的播放器内核，都需要创建一个对应的适配器。**\n\n3.  **`player_factory.dart`**: 这是一个工厂，它就像一个调度员。它会根据用户的设置（比如用户在设置中选择了“VLC内核”）来决定实例化哪一个适配器。UI代码不关心具体是哪个适配器，它只管向工厂索要一个“符合`AbstractPlayer`标准的播放器”。\n\n## 实战步骤：集成一个新的播放器内核（以VLC为例）\n\n假设我们要集成一个名为 `dart_vlc` 的第三方播放器库。\n\n### 第 1 步：创建分支\n\n```bash\ngit checkout -b feat/add-vlc-player-kernel\n```\n\n### 第 2 步：添加依赖\n\n首先，我们需要将 `dart_vlc` 库添加到项目中。\n\n```bash\nflutter pub add dart_vlc\n```\n(这会自动更新 `pubspec.yaml` 文件)\n\n### 第 3 步：创建新的播放器适配器\n\n这是最核心的一步。\n\n1.  在 `lib/player_abstraction/` 目录下，创建一个新文件 `vlc_player_adapter.dart`。\n2.  在该文件中，创建一个新类 `VlcPlayerAdapter`，并让它实现 `AbstractPlayer` 接口。\n\n    ```dart\n    import 'package:dart_vlc/dart_vlc.dart' as vlc;\n    import './abstract_player.dart';\n    // ... 其他必要的导入\n\n    class VlcPlayerAdapter implements AbstractPlayer {\n      // 在这里，你需要实现 AbstractPlayer 接口中定义的所有方法和属性。\n      // 例如:\n      \n      // 内部持有一个VLC播放器的实例\n      final vlc.Player _player;\n\n      VlcPlayerAdapter() : _player = vlc.Player(id: 69420);\n\n      @override\n      Future<void> playDirectly() async {\n        _player.play();\n      }\n\n      @override\n      Future<void> pauseDirectly() async {\n        _player.pause();\n      }\n\n      @override\n      void seek({required int position}) {\n        _player.seek(Duration(milliseconds: position));\n      }\n\n      @override\n      double get volume => _player.volume;\n\n      @override\n      set volume(double value) {\n        _player.setVolume(value);\n      }\n      \n      // ... 你需要继续实现所有其他必须的方法和属性 ...\n      // ... 比如 state, textureId, mediaInfo, dispose 等 ...\n    }\n    ```\n\n**如何处理不匹配的功能？**\n你可能会发现 `dart_vlc` 的 API 和 `AbstractPlayer` 的要求不完全一致。这就是“适配器”模式的价值所在。你需要在这里做一些转换工作。例如：\n\n*   `AbstractPlayer` 要求 `state` 是一个 `PlayerPlaybackState` 枚举，而 `dart_vlc` 可能用一个布尔值 `isPlaying`。你需要在 `get state` 方法里进行转换：`return _player.playback.isPlaying ? PlayerPlaybackState.playing : PlayerPlaybackState.paused;`\n*   如果 `dart_vlc` 不支持某个功能（比如设置解码器），你可以在对应的方法里留空或打印一条警告信息。\n\n### 第 4 步：将新内核注册到工厂中\n\n现在，适配器已经创建好了，我们需要告诉工厂“我们有了一个新选择”。\n\n1.  打开 `lib/player_abstraction/player_factory.dart`。\n2.  首先，在 `PlayerKernelType` 枚举中，添加一个新的内核类型：\n    ```dart\n    enum PlayerKernelType {\n      mdk,\n      mediaKit,\n      videoPlayer,\n      vlc, // 新增的VLC内核\n    }\n    ```\n3.  然后，在 `PlayerFactory` 类的 `createPlayer` 方法（或者类似的创建逻辑中）添加一个新的 `case`。\n\n    ```dart\n    // ... 在 player_factory.dart 的某个地方 ...\n    import './vlc_player_adapter.dart'; // 导入你的新适配器\n\n    // ... 在 createPlayer 方法中 ...\n    AbstractPlayer createPlayer(PlayerKernelType type) {\n        switch (type) {\n            case PlayerKernelType.mdk:\n                return MdkPlayerAdapter();\n            case PlayerKernelType.mediaKit:\n                return MediaKitPlayerAdapter();\n            case PlayerKernelType.vlc: // 新增的 case\n                return VlcPlayerAdapter(); // 返回你的新适配器实例\n            default:\n                // ...\n        }\n    }\n    ```\n\n### 第 5 步：在设置页面添加入口\n\n最后，用户需要一个地方来选择使用你的新内核。\n\n1.  找到处理播放器设置的UI文件（例如 `lib/pages/settings/player_settings_page.dart`）。\n2.  在选择播放器内核的下拉菜单或列表中，添加“VLC”这个新选项。\n3.  确保当用户选择“VLC”时，应用会将 `PlayerKernelType.vlc` 这个值保存到 `SharedPreferences` 中，这样 `PlayerFactory` 在下次启动时就能读取到正确的设置。\n\n### 第 6 步：测试、提交、创建PR\n\n现在，你可以运行应用，进入设置，选择VLC内核，然后播放一个视频来测试你的集成是否成功。完成测试后，按照标准流程提交你的代码和 Pull Request。\n\n## 总结\n\n添加一个新的播放器内核是一项复杂的任务，它需要你仔细阅读并理解第三方库的文档和 `AbstractPlayer` 接口的要求。但是，通过遵循上述步骤，你可以系统地完成这项工作。记住，当你遇到困难时，可以随时向 AI 助手请教，例如：“`dart_vlc` 这个库如何获取视频的总时长？请给我一个代码示例。”\n\n---\n\n**⬅️ 上一篇: [7. 如何开发主题和自定义样式](#CONTRIBUTING_GUIDE-07-Theme-Development)** | **➡️ 下一篇: [9. (进阶) 如何添加新的弹幕内核](#CONTRIBUTING_GUIDE-09-Adding-a-New-Danmaku-Kernel)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-09-Adding-a-New-Danmaku-Kernel",
            "name": "9. (进阶) 如何添加新的弹幕内核",
            "content": "# 9. (进阶) 如何添加新的弹幕内核\n\n与播放器系统一样，NipaPlay-Reload 的弹幕系统也经过了精心的设计，以实现高度的可扩展性。本章将指导你如何为应用添加新的弹幕功能，这主要包括两个方向：**接入新的弹幕数据源** 和 **创建新的弹幕渲染引擎**。\n\n## 弹幕系统架构解析\n\n在 `lib/danmaku_abstraction/` 和 `lib/danmaku_gpu/` 目录中，我们可以找到弹幕系统的核心。\n\n1.  **弹幕数据模型 (`danmaku_content_item.dart`)**: 这是所有弹幕的“身份证”。无论弹幕数据来自B站、弹弹play，还是本地XML文件，在应用内流通时，都必须被转换成统一的 `DanmakuContentItem` 对象。它定义了弹幕的文本、颜色、类型（滚动、顶部、底部）等标准属性。\n\n2.  **弹幕渲染器 (`danmaku_text_renderer.dart`)**: 这是一个抽象层，它只关心一件事：“给我一个 `DanmakuContentItem` 数据，我应该如何把它画在屏幕上？”\n    *   **CPU实现 (`CpuDanmakuTextRenderer`)**: 这是默认的实现，它使用Flutter标准的 `Text` Widget来显示弹幕，并巧妙地通过多个 `Shadow` 来模拟描边效果。这种方式实现简单，但在弹幕数量巨大时可能会有性能瓶頸。\n    *   **GPU实现 (`gpu_danmaku_base_renderer.dart`等)**: 这是一个更高效的实现。它不使用 `Text` Widget，而是通过 `CustomPainter` 直接在画布（`Canvas`）上绘制文本。它利用 `DynamicFontAtlas`（动态字体图集）技术来优化纹理，从而大幅提升海量弹幕下的渲染性能。\n\n3.  **弹幕布局与容器 (`danmaku_container.dart`等)**: 这些组件负责弹幕的“调度”和“管理”，包括计算弹幕的运动轨迹、处理碰撞检测、分配轨道，以及将弹幕在视频上正确地叠加显示出来。\n\n## 方向一：接入新的弹幕数据源\n\n这是最常见的贡献方式。比如，你希望NipaPlay-Reload能够加载一种它目前还不支持的弹幕文件格式（例如 `ass` 特效字幕作为弹幕）。\n\n### 第 1 步：创建解析器 (Parser)\n\n你需要创建一个新的Dart类，我们称之为“解析器”。这个类的唯一职责就是读取原始的弹幕文件（或API响应），并将其内容逐条转换成 `DanmakuContentItem` 对象的列表。\n\n1.  在 `lib/services/` 目录下创建一个新文件，例如 `ass_danmaku_parser.dart`。\n2.  创建一个类，例如 `AssDanmakuParser`。\n3.  在这个类中，创建一个核心方法，例如 `parse(String rawContent)`。\n\n    ```dart\n    import 'package:nipaplay/danmaku_abstraction/danmaku_content_item.dart';\n    import 'package:flutter/material.dart'; // 需要导入以使用Color\n\n    class AssDanmakuParser {\n      \n      List<DanmakuContentItem> parse(String rawAssContent) {\n        final List<DanmakuContentItem> danmakuList = [];\n        \n        // 在这里编写你的解析逻辑\n        // 1. 按行分割 rawAssContent 字符串\n        // 2. 识别出事件行 (Dialogue)\n        // 3. 从每行中提取出时间、文本、颜色、类型等信息\n        // 4. 将提取的信息实例化为一个 DanmakuContentItem 对象\n        // 5. 将该对象添加到 danmakuList 中\n\n        // 伪代码示例：\n        for (final line in rawAssContent.split('\\n')) {\n          if (line.startsWith('Dialogue:')) {\n            // final startTime = parseStartTime(line); // 你需要自己实现这些辅助方法\n            // final text = parseText(line);\n            // final color = parseColor(line);\n            // final type = parseDanmakuType(line);\n\n            // danmakuList.add(DanmakuContentItem(\n            //   text,\n            //   color: color,\n            //   type: type,\n            //   // 注意：还需要一个时间属性，这可能需要你对 DanmakuContentItem 做一些了解\n            //   // 或者在更高层（调用方）处理时间戳\n            // ));\n          }\n        }\n        \n        return danmakuList;\n      }\n    }\n    ```\n\n**与 AI 协作**:\n解析文件格式是一项繁琐但模式化的工作。你可以把 `ass` 文件的格式规范，或者一个文件示例交给 AI，然后提问：\n\n> “这是一个 `.ass` 字幕文件的示例：[粘贴示例内容]。请帮我用 Dart 编写一个解析器，它可以将每一行‘Dialogue’解析出来，并提取出开始时间、文本内容和样式信息。然后将这些信息转换成 `DanmakuContentItem` 对象列表。”\n\n### 第 2 步：集成解析器\n\n解析器写好后，你需要找到应用中加载弹幕的地方，并调用你的解析器。\n\n这通常发生在用户选择一个本地弹幕文件后，或者从网络服务（如弹弹play）获取到弹幕数据后。你可以在 `lib/services/dandanplay_service_io.dart` 或处理文件选择的UI逻辑中找到相关代码。你需要添加一个逻辑分支，当识别到文件是 `.ass` 格式时，就实例化并调用你的 `AssDanmakuParser`。\n\n## 方向二：创建新的弹幕渲染引擎\n\n这是一个更具挑战性的任务，适合那些对图形学和性能优化感兴趣的贡献者。假设你想创建一个基于 `Flame` 游戏引擎的弹幕渲染器。\n\n### 第 1 步：创建新的渲染器类\n\n1.  在 `lib/` 下创建一个新目录，例如 `danmaku_flame/`。\n2.  在该目录下，创建一个文件，例如 `flame_danmaku_renderer.dart`。\n3.  创建一个类 `FlameDanmakuRenderer`，让它继承 `DanmakuTextRenderer`。\n\n    ```dart\n    import 'package:nipaplay/danmaku_abstraction/danmaku_text_renderer.dart';\n    import 'package:nipaplay/danmaku_abstraction/danmaku_content_item.dart';\n    import 'package:flutter/material.dart';\n\n    class FlameDanmakuRenderer extends DanmakuTextRenderer {\n      const FlameDanmakuRenderer();\n\n      @override\n      Widget build(\n        BuildContext context,\n        DanmakuContentItem content,\n        double fontSize,\n        double opacity,\n      ) {\n        // 在这里，你需要返回一个 Widget\n        // 这个 Widget 内部会使用 Flame 游戏引擎来渲染弹幕文本\n        // 这可能涉及到创建一个小型的 FlameGame 实例，\n        // 并在其中添加一个 TextComponent 来显示 content.text。\n        \n        // 这是一个高度简化的伪代码\n        // return FlameGameWidget(\n        //   game: MyDanmakuGame(content.text, content.color, fontSize),\n        // );\n        \n        // 你需要自己去实现 MyDanmakuGame\n        return Container(); // 返回一个占位符\n      }\n    }\n    ```\n\n### 第 2 步：注册新的渲染引擎\n\n1.  打开 `lib/danmaku_abstraction/danmaku_kernel_factory.dart` (如果存在，或者类似的管理文件)。\n2.  在 `DanmakuRenderEngine` 枚举中添加你的新引擎，例如 `flame`。\n3.  修改工厂的创建逻辑，当被要求创建 `flame` 引擎时，返回你的 `FlameDanmakuRenderer` 的实例。\n4.  最后，在设置页面中添加一个选项，允许用户选择“Flame渲染引擎”。\n\n## 总结\n\n无论是扩展数据源还是革新技术栈，弹幕系统都为你提供了广阔的创造空间。通过理解并遵循现有的抽象设计，你的贡献将能无缝地融入 NipaPlay-Reload，为用户带来更丰富、更流畅的弹幕体验。\n\n---\n\n**⬅️ 上一篇: [8. (进阶) 如何添加新的播放器内核](#CONTRIBUTING_GUIDE-08-Adding-a-New-Player-Kernel)** | **➡️ 下一篇: [10. (进阶) 如何进行平台特定开发](#CONTRIBUTING_GUIDE-10-Platform-Specific-Development)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-10-Platform-Specific-Development",
            "name": "10. (进阶) 如何进行平台特定开发",
            "content": "# 10. (进阶) 如何进行平台特定开发\n\nNipaPlay-Reload 是一个跨平台应用，这意味着我们的代码需要能够优雅地处理不同操作系统（Windows, macOS, Linux, Android, iOS, Web）的特性和差异。本章将指导你如何编写平台特定的代码，以及如何只在特定设备上测试这些功能。\n\n## 平台特定代码的核心技术\n\n在 Flutter 中，我们有多种方法来处理平台差异。以下是项目中最常用的几种技术，从简单到复杂排序。\n\n### 方法一：使用 `Platform` 类和 `kIsWeb`\n\n这是最常用、最直接的方法，用于在运行时检查当前平台。\n\n*   **对于原生平台 (PC/Mobile)**: Flutter 的 `dart:io` 库提供了一个 `Platform` 类，你可以通过它来判断当前的操作系统。\n    *   `Platform.isWindows`\n    *   `Platform.isMacOS`\n    *   `Platform.isLinux`\n    *   `Platform.isAndroid`\n    *   `Platform.isIOS`\n\n*   **对于 Web 平台**: 由于 `dart:io` 在 Web 环境中不可用，Flutter 提供了一个全局常量 `kIsWeb` (来自 `foundation.dart`) 来进行判断。\n\n**代码示例**：假设我们要创建一个根据不同平台显示不同文本的 Widget。\n\n```dart\nimport 'dart:io'; // 导入 Platform 类\nimport 'package:flutter/foundation.dart' show kIsWeb; // 导入 kIsWeb\n\nWidget buildPlatformSpecificWidget() {\n  String platformText;\n\n  if (kIsWeb) {\n    platformText = \"你好，网页用户！\";\n  } else if (Platform.isWindows) {\n    platformText = \"你好，Windows 用户！\";\n  } else if (Platform.isAndroid) {\n    platformText = \"你好，安卓用户！\";\n  } else {\n    platformText = \"你好，其他平台的用户！\";\n  }\n\n  return Text(platformText);\n}\n```\n\n### 方法二：条件导入 (Conditional Import)\n\n当你需要在一个文件中根据平台导入不同的依赖时，条件导入就派上用场了。一个典型的场景是，你的代码同时需要支持Web和原生平台，但其中一部分功能依赖于 `dart:io`（Web不支持）。\n\n**工作原理**: 你可以创建一个主文件，然后根据条件导入两个不同的实现文件。\n\n1.  **创建一个接口文件 (`*.dart`)**:\n    ```dart\n    // a_feature.dart\n    abstract class Feature {\n      void doSomething();\n    }\n    \n    // 这个工厂方法会根据平台返回不同的实例\n    Feature getFeature();\n    ```\n2.  **创建一个原生实现 (`*_io.dart`)**:\n    ```dart\n    // a_feature_io.dart\n    import 'dart:io';\n    import 'a_feature.dart';\n\n    class FeatureIO implements Feature {\n      @override\n      void doSomething() {\n        print(\"在原生平台上运行: ${Platform.operatingSystem}\");\n      }\n    }\n\n    Feature getFeature() => FeatureIO();\n    ```\n3.  **创建一个Web存根 (Stub) 实现 (`*_web.dart`)**:\n    ```dart\n    // a_feature_web.dart\n    import 'a_feature.dart';\n\n    class FeatureWeb implements Feature {\n      @override\n      void doSomething() {\n        print(\"在Web平台上运行\");\n      }\n    }\n\n    Feature getFeature() => FeatureWeb();\n    ```\n4.  **在主文件中使用条件导入**:\n    ```dart\n    // main_logic.dart\n    import 'a_feature.dart'\n      if (dart.library.io) 'a_feature_io.dart' // 如果 dart:io 存在 (非Web)，则导入这个文件\n      if (dart.library.html) 'a_feature_web.dart'; // 如果 dart:html 存在 (Web)，则导入这个文件\n\n    void myAppLogic() {\n      final feature = getFeature();\n      feature.doSomething();\n    }\n    ```\n    现在，当你调用 `myAppLogic()` 时，它会在原生平台上打印操作系统，在Web上打印另一条信息，而你的主逻辑代码完全不需要 `if/else` 判断。\n\n### 方法三：平台通道 (Platform Channels) - 最高级\n\n当你需要调用原生平台的 API（比如获取 Android 的电池电量、调用 Windows 的一个特定 DLL 文件）时，就需要使用平台通道。\n\n这是一个更高级的主题，它涉及到在 Dart 代码和原生代码（Kotlin/Java for Android, Swift/Objective-C for iOS, C++ for Windows/Linux）之间传递消息。\n\n由于其复杂性，我们建议只有在非常必要的情况下才使用此方法。如果你需要实现这样的功能，请参考 Flutter 官方文档关于 [平台通道](https://flutter.cn/docs/platform-integration/platform-channels) 的详细教程。\n\n## 实战：只在 Windows 平台添加一个“检查NVIDIA显卡”的按钮\n\n让我们通过一个实例，来练习如何在设置页面中添加一个仅限 Windows 的功能。\n\n### 第 1 步：定位并修改UI\n\n1.  打开设置页面文件，例如 `lib/pages/settings/player_settings_page.dart`。\n2.  找到你想要添加按钮的位置，比如在解码器设置旁边。\n3.  使用 `Platform.isWindows` 来决定是否构建这个按钮。\n\n    ```dart\n    import 'dart:io';\n    // ... 其他导入\n\n    class PlayerSettingsPage extends StatelessWidget {\n      // ...\n      @override\n      Widget build(BuildContext context) {\n        return Scaffold(\n          // ...\n          body: ListView(\n            children: [\n              // ... 其他设置项 ...\n\n              // 只在 Windows 平台上构建这个 ListTile\n              if (Platform.isWindows)\n                ListTile(\n                  title: const Text('检查 NVIDIA 显卡'),\n                  subtitle: const Text('调用原生命令检查GPU信息'),\n                  onTap: () {\n                    // 在点击时调用我们的平台特定逻辑\n                    _showNvidiaGpuStatus(context);\n                  },\n                ),\n\n              // ... 其他设置项 ...\n            ],\n          ),\n        );\n      }\n      \n      // ...\n    }\n    ```\n\n### 第 2 步：实现平台特定逻辑\n\n现在我们来实现 `_showNvidiaGpuStatus` 方法。我们将复用项目中已有的 `_checkForNvidiaGpu` 逻辑。\n\n1.  假设 `_checkForNvidiaGpu` 定义在 `lib/utils/decoder_manager.dart` 中，并且可以被外部访问。\n2.  在你的 `player_settings_page.dart` 中，实现 `_showNvidiaGpuStatus` 方法。\n\n    ```dart\n    // (接上文)\n    \n    // 假设 DecoderManager 是可以获取的实例\n    final decoderManager = DecoderManager(); \n\n    void _showNvidiaGpuStatus(BuildContext context) {\n      // 再次确认是 Windows 平台\n      if (!Platform.isWindows) {\n        return;\n      }\n      \n      final hasNvidia = decoderManager.checkForNvidiaGpu(); // 调用已有逻辑\n      final message = hasNvidia ? '检测到 NVIDIA 显卡。' : '未检测到 NVIDIA 显卡。';\n      \n      // 显示一个弹窗来展示结果\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: const Text('显卡检测结果'),\n          content: Text(message),\n          actions: [\n            TextButton(\n              child: const Text('好的'),\n              onPressed: () => Navigator.of(context).pop(),\n            ),\n          ],\n        ),\n      );\n    }\n    ```\n\n### 第 3 步：在特定设备上测试\n\n现在代码已经写好了，但如何确保它只在 Windows 上运行且表现正常？\n\n1.  **选择目标设备**: 在你的代码编辑器（如 VS Code 或 Android Studio）的右下角，有一个设备选择器。\n2.  **启动 Windows 应用**: 点击设备选择器，选择 “Windows (desktop)”。\n3.  **运行**: 按下 `F5` 或点击运行按钮。Flutter 会将你的应用编译并作为一个原生的 Windows 应用启动。\n4.  **测试功能**: 在运行起来的 Windows 应用中，导航到设置页面，你应该能看到“检查 NVIDIA 显卡”按钮。点击它，应该能看到弹窗结果。\n5.  **在其他平台验证**: 之后，将目标设备切换到“Chrome (web)”或一个安卓模拟器，再次运行应用。在这些平台上，设置页面中**不应该**出现那个按钮。\n\n通过这种方式，你就可以有效地开发和测试平台专属的功能了。\n\n---\n\n**⬅️ 上一篇: [9. (进阶) 如何添加新的弹幕内核](#CONTRIBUTING_GUIDE-09-Adding-a-New-Danmaku-Kernel)** | **➡️ 下一篇: [11. 非代码贡献：同样重要！](#CONTRIBUTING_GUIDE-11-Non-Coding-Contributions)**\n"
        },
        {
            "id": "CONTRIBUTING_GUIDE-11-Non-Coding-Contributions",
            "name": "11. 非代码贡献：同样重要！",
            "content": "# 11. 非代码贡献：同样重要！\n\n你是否热爱 NipaPlay-Reload，并渴望为它做点什么，但又对编程望而却步？好消息是，一个成功的开源项目远不止代码那么简单。你的热情和才华在很多非编程领域同样能发挥巨大的价值。\n\n本章将为你介绍几种非常有意义的非代码贡献方式。\n\n## 1. 软件分发：让更多人发现和使用\n\n一个好的应用，如果安装过程繁琐，也会劝退很多潜在用户。如果你能帮助我们将 NipaPlay-Reload 发布到各种包管理工具和应用商店，那将是巨大的贡献。\n\n### 发布到包管理工具\n\n包管理器（如 `Homebrew`, `Chocolatey`, `winget`, `Flatpak`, `Snap`）允许用户通过一条简单的命令就安装好软件。\n\n*   **你能做什么**:\n    *   学习特定包管理器的打包脚本规范（比如 Homebrew 的 Formulae，Chocolatey 的 `nuspec` 文件）。\n    *   为 NipaPlay-Reload 编写、测试并提交打包脚本。\n    *   维护这些包，在项目发布新版本时及时更新它们。\n*   **如何开始**:\n    1.  选择一个你熟悉或感兴趣的平台及其包管理器（例如，Windows 平台的 `winget` 或 `Chocolatey`）。\n    2.  阅读该包管理器的官方文档，了解如何为第三方应用创建包。\n    3.  在 NipaPlay-Reload 的 GitHub Issue 区创建一个新的 Issue，标题如：“[Feature Request] Publish NipaPlay-Reload to Chocolatey”，并表达你愿意负责此事。这样可以避免重复工作，并获得开发者的支持（例如提供编译好的二进制文件）。\n\n### 发布到应用商店\n\n将应用发布到官方应用商店（如 Microsoft Store, Mac App Store, Google Play等）可以极大地提升应用的信誉和曝光度。\n\n*   **你能做什么**:\n    *   了解特定应用商店的上架流程和要求。这通常需要一个开发者账号。\n    *   处理应用的打包、签名、元数据（截图、介绍、更新日志）填写等上架事宜。\n*   **如何开始**: 这个过程通常需要项目核心成员的协作，因为涉及到官方账号。最好的方式同样是先在 GitHub Issue 中提出你的想法和计划，与项目组进行沟通。\n\n## 2. 宣传推广：撰写推荐文章\n\n“酒香也怕巷子深”。好的口碑和文章能让项目被更多人看到。\n\n*   **你能做什么**:\n    *   在你的个人博客、知乎、B站、少数派等平台上，撰写一篇关于 NipaPlay-Reload 的评测或推荐文章。\n    *   文章可以分享你的使用体验、你最喜欢的功能、与其他播放器的对比，或者如何利用 NipaPlay-Reload 获得最佳观影体验的教程。\n    *   制作一个介绍视频，展示应用的酷炫功能。\n*   **如何开始**:\n    1.  尽情使用 NipaPlay-Reload，找到你最想分享的闪光点。\n    2.  创作并发布你的文章或视频。\n    3.  完成后，欢迎将你的作品链接分享到项目的 GitHub Discussions 或相关的社区群里，我们会非常感谢，并可能将其置顶或转发！\n\n## 3. 艺术创作：绘制新的看板娘或主题\n\nNipaPlay-Reload 的视觉风格是其魅力的一部分。如果你擅长绘画或UI设计，你的才华将有用武之地。\n\n*   **你能做什么**:\n    *   为应用设计并绘制一个全新的“看板娘”（Mascot/Character Art）。一个可爱的看板娘形象能让应用更具亲和力。\n    *   设计一套全新的应用图标或主题配色。\n*   **如何开始**:\n    1.  将你的设计草图或想法发布到 GitHub Discussions 中，以收集社区的反馈。\n    2.  一旦设计成熟，你可以提供符合应用要求（如特定分辨率、透明背景的 PNG 文件）的最终文件。\n    3.  开发者会非常乐意将优秀的设计作为预设选项之一，集成到应用中，并署上你的大名。\n\n## 其他贡献方式\n\n*   **测试和反馈**: 在开发版本发布时，积极试用并提交详细的 Bug报告或改进建议。\n*   **文档完善**: 帮助我们改进 `CONTRIBUTING_GUIDE` 或者应用的帮助文档，使其更清晰易懂。\n*   **社区管理**: 帮助回答新用户在社区（如 Discord, Telegram 群）中提出的问题。\n\n你的任何形式的贡献，都是对 NipaPlay-Reload 项目的宝贵支持。感谢你的热情！\n\n---\n\n**⬅️ 上一篇: [10. (进阶) 如何进行平台特定开发](#CONTRIBUTING_GUIDE-10-Platform-Specific-Development)** | **[⬆️ 返回目录](#CONTRIBUTING_GUIDE-00-Introduction)**\n"
        }
    ]
}